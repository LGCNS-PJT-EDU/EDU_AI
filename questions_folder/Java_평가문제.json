[
  {
    "question": "Java에서 정수형 기본 타입으로 올바른 것은?",
    "option1": "int",
    "option2": "Integer",
    "option3": "float",
    "option4": "char",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "Java에서 문자를 저장하는 자료형은?",
    "option1": "char",
    "option2": "String",
    "option3": "int",
    "option4": "boolean",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "Java 프로그램의 시작점이 되는 메서드는?",
    "option1": "main",
    "option2": "start",
    "option3": "run",
    "option4": "launch",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Java에서 기본형 타입이 아닌 것은?",
    "option1": "boolean",
    "option2": "double",
    "option3": "String",
    "option4": "char",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "기본형 타입과 매핑되는 래퍼 클래스가 틀린 것은?",
    "option1": "int - Integer",
    "option2": "boolean - Boolean",
    "option3": "double - Double",
    "option4": "char - Characterized",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "Java에서 long 타입 리터럴을 올바르게 표기한 것은?",
    "option1": "1000",
    "option2": "1000l",
    "option3": "1000L",
    "option4": "1000.0",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "다음 중 char 타입 리터럴로 유효하지 않은 것은?",
    "option1": "'A'",
    "option2": "'\\u0041'",
    "option3": "'\\n'",
    "option4": "\"A\"",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "byte와 관련된 설명으로 틀린 것은?",
    "option1": "-128 ~ 127 범위",
    "option2": "8비트 크기",
    "option3": "기본값은 0",
    "option4": "음수를 저장할 수 없다",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "다음 중 자동 형변환이 발생하는 경우는?",
    "option1": "int → byte",
    "option2": "char → int",
    "option3": "double → float",
    "option4": "long → int",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "Java에서 변수를 선언할 수 없는 예는?",
    "option1": "int _val;",
    "option2": "float %rate;",
    "option3": "double value1;",
    "option4": "char letter;",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "기초 문법과 자료형",
    "chapterNum": 1
  },
  {
    "question": "Java에서 while문과 do-while문의 차이로 옳은 것은?",
    "option1": "둘 다 조건이 앞에 온다",
    "option2": "while은 한 번은 반드시 실행된다",
    "option3": "do-while은 조건이 뒤에 온다",
    "option4": "do-while은 조건 없이 반복된다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "for문에서 조건이 false일 경우 어떻게 되는가?",
    "option1": "무한 루프에 빠진다",
    "option2": "한 번은 실행된다",
    "option3": "아예 실행되지 않는다",
    "option4": "예외가 발생한다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "다음 중 break문의 올바른 사용 목적은?",
    "option1": "루프를 중단한다",
    "option2": "조건문을 생략한다",
    "option3": "예외 처리를 한다",
    "option4": "다음 루프로 건너뛴다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "continue 문을 사용하면 어떻게 되는가?",
    "option1": "루프를 종료한다",
    "option2": "해당 루프의 나머지를 건너뛴다",
    "option3": "조건문을 무시한다",
    "option4": "에러가 발생한다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "다음 중 조건문으로만 사용되는 것은?",
    "option1": "for",
    "option2": "while",
    "option3": "if",
    "option4": "switch",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "switch문에서 case 다음에 올 수 없는 타입은?",
    "option1": "int",
    "option2": "char",
    "option3": "boolean",
    "option4": "String",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "중첩 for문을 사용할 때 고려해야 할 사항은?",
    "option1": "무조건 속도가 빨라진다",
    "option2": "루프가 독립적으로 실행된다",
    "option3": "전체 반복 횟수 증가",
    "option4": "조건문을 생략할 수 있다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "Java의 향상된 for문은 어떤 컬렉션에 사용 가능한가?",
    "option1": "배열",
    "option2": "List",
    "option3": "Set",
    "option4": "모두 가능",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "다음 중 무한 루프를 만드는 코드로 올바른 것은?",
    "option1": "for(;;)",
    "option2": "while(true)",
    "option3": "do{}while(true)",
    "option4": "모두 가능",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "if-else if-else 구조에서 else는 언제 실행되는가?",
    "option1": "항상 실행된다",
    "option2": "조건이 true일 때 실행",
    "option3": "모든 조건이 false일 때",
    "option4": "처음 조건이 false일 때",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "제어문과 반복문",
    "chapterNum": 2
  },
  {
    "question": "객체 지향 프로그래밍의 4대 특징 중 하나가 아닌 것은?",
    "option1": "상속",
    "option2": "추상화",
    "option3": "캡슐화",
    "option4": "동기화",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "클래스와 객체의 관계로 올바른 것은?",
    "option1": "객체는 클래스의 인스턴스이다",
    "option2": "클래스는 객체의 결과물이다",
    "option3": "객체는 설계도이다",
    "option4": "클래스는 객체의 조합이다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "생성자의 특징으로 틀린 것은?",
    "option1": "클래스 이름과 동일",
    "option2": "리턴 타입이 있다",
    "option3": "객체 생성 시 호출",
    "option4": "오버로딩 가능",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "오버로딩의 조건으로 올바른 것은?",
    "option1": "매개변수 개수 또는 타입이 달라야 한다",
    "option2": "리턴 타입만 다르면 된다",
    "option3": "메서드 이름과 타입 모두 달라야 한다",
    "option4": "같은 이름, 같은 매개변수",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "오버라이딩의 특징은?",
    "option1": "동일한 이름과 시그니처를 사용",
    "option2": "다른 이름을 사용",
    "option3": "다른 리턴 타입 사용",
    "option4": "private 메서드 가능",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "abstract 키워드를 사용할 수 없는 곳은?",
    "option1": "클래스",
    "option2": "메서드",
    "option3": "필드",
    "option4": "인터페이스",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "인터페이스의 특징은?",
    "option1": "다중 구현 가능",
    "option2": "필드를 가질 수 있다",
    "option3": "생성자를 가질 수 있다",
    "option4": "메서드 구현 필수",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "final 클래스의 특징은?",
    "option1": "상속 가능",
    "option2": "객체 생성 불가",
    "option3": "상속 불가",
    "option4": "변수로만 사용",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "super 키워드는 무엇을 참조하는가?",
    "option1": "현재 클래스",
    "option2": "부모 클래스",
    "option3": "자식 클래스",
    "option4": "추상 클래스",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "this 키워드의 역할은?",
    "option1": "클래스 이름 참조",
    "option2": "정적 변수 참조",
    "option3": "현재 객체 참조",
    "option4": "부모 객체 참조",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "객체 지향 프로그래밍",
    "chapterNum": 3
  },
  {
    "question": "List의 특징으로 올바른 것은?",
    "option1": "중복 불가",
    "option2": "순서 없음",
    "option3": "중복 허용",
    "option4": "정렬 필수",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "Set의 특징으로 올바른 것은?",
    "option1": "중복 허용",
    "option2": "순서 보장",
    "option3": "중복 불허",
    "option4": "키-값 저장",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "Map은 어떤 구조인가?",
    "option1": "key-value",
    "option2": "index-value",
    "option3": "key-key",
    "option4": "value-value",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "다음 중 List를 구현하지 않는 것은?",
    "option1": "ArrayList",
    "option2": "LinkedList",
    "option3": "Vector",
    "option4": "HashMap",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "HashMap과 TreeMap의 차이는?",
    "option1": "HashMap은 정렬된다",
    "option2": "TreeMap은 정렬 지원",
    "option3": "둘 다 정렬된다",
    "option4": "TreeMap은 중복 허용",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "제네릭을 사용하는 이유는?",
    "option1": "코드 축소",
    "option2": "타입 안정성 확보",
    "option3": "메모리 절약",
    "option4": "속도 향상",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "다음 중 제네릭 타입 선언이 올바른 것은?",
    "option1": "List<int>",
    "option2": "List<Object>",
    "option3": "List<>",
    "option4": "List{String}",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "Iterator의 주요 기능은?",
    "option1": "요소 정렬",
    "option2": "요소 반복",
    "option3": "요소 삭제",
    "option4": "요소 추가",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "List에서 요소를 삽입할 수 있는 메서드는?",
    "option1": "add()",
    "option2": "put()",
    "option3": "insert()",
    "option4": "append()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "HashSet은 어떤 특성을 가진가?",
    "option1": "순서 보장",
    "option2": "중복 허용",
    "option3": "중복 제거",
    "option4": "키-값 구조",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "컬렉션과 제네릭",
    "chapterNum": 4
  },
  {
    "question": "IOException은 어떤 예외인가?",
    "option1": "Checked 예외",
    "option2": "Unchecked 예외",
    "option3": "컴파일 오류",
    "option4": "논리 오류",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "try-catch-finally에서 finally 블록은 언제 실행되는가?",
    "option1": "항상",
    "option2": "catch 실행 시",
    "option3": "예외 없을 때만",
    "option4": "조건부 실행",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "throws 키워드는 무엇을 의미하는가?",
    "option1": "예외 발생",
    "option2": "예외 전달",
    "option3": "예외 제거",
    "option4": "예외 종료",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "catch 블록은 무엇을 처리하는가?",
    "option1": "정상 종료",
    "option2": "예외 처리",
    "option3": "오류 출력",
    "option4": "파일 쓰기",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "예외 발생 없이도 finally가 실행되는가?",
    "option1": "예",
    "option2": "아니오",
    "option3": "조건에 따라 다름",
    "option4": "컴파일러가 결정",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "예외 클래스의 최상위 클래스는?",
    "option1": "Throwable",
    "option2": "Exception",
    "option3": "RuntimeException",
    "option4": "Error",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "FileReader는 어떤 스트림에 속하는가?",
    "option1": "입력 스트림",
    "option2": "출력 스트림",
    "option3": "버퍼 스트림",
    "option4": "바이트 스트림",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "파일에 내용을 쓰는 스트림은?",
    "option1": "FileInputStream",
    "option2": "FileOutputStream",
    "option3": "BufferedReader",
    "option4": "Scanner",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "BufferedReader의 주요 기능은?",
    "option1": "파일 쓰기",
    "option2": "라인 단위 읽기",
    "option3": "바이트 읽기",
    "option4": "객체 직렬화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  },
  {
    "question": "예외 처리에서 다중 catch를 사용하면?",
    "option1": "모든 예외가 무시됨",
    "option2": "하나의 예외만 처리 가능",
    "option3": "여러 예외를 개별 처리",
    "option4": "finally가 생략됨",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "예외 처리와 파일 I/O",
    "chapterNum": 5
  }
]