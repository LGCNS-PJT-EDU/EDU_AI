[
  {
    "question": "Vue 템플릿에서 데이터 바인딩을 위한 기본 구문은?",
    "option1": "{{  }}",
    "option2": "[[  ]]",
    "option3": "{{{  }}}",
    "option4": "(())",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "Vue 인스턴스를 생성할 때 가장 먼저 호출되는 라이프사이클 훅은?",
    "option1": "beforeCreate",
    "option2": "created",
    "option3": "mounted",
    "option4": "beforeMount",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "템플릿에서 HTML 특수문자를 이스케이프하지 않고 그대로 출력하려면 사용하는 구문은?",
    "option1": "v-html=\"rawHtml\"",
    "option2": "{{ rawHtml }}",
    "option3": "v-bind:html=\"rawHtml\"",
    "option4": "v-text=\"rawHtml\"",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Vue 템플릿에 JavaScript 표현식을 사용할 수 없는 위치는?",
    "option1": "v-bind 디렉티브 값",
    "option2": "v-on 디렉티브 핸들러",
    "option3": "속성 이름(attribute key)",
    "option4": "텍스트 보간(interpolation) 안",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "v-bind:class에 객체를 전달할 때, 클래스가 적용되는 조건은?",
    "option1": "키에 대응하는 값이 true일 때",
    "option2": "키가 문자열이 아닐 때",
    "option3": "값이 null일 때",
    "option4": "객체 길이가 0일 때",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "data 옵션에서 함수가 아닌 객체를 반환하면 발생하는 문제는?",
    "option1": "모든 인스턴스가 동일 객체를 공유해 반응성 오류",
    "option2": "템플릿 파싱이 실패하여 빌드 중단",
    "option3": "watcher가 자동으로 해제됨",
    "option4": "props 전달이 차단됨",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "‘this.message’가 DOM에 반영되는 시점은? (mounted 훅 내부에서 변경)",
    "option1": "mounted 훅 직후에 반영된다",
    "option2": "nextTick 이후 첫 렌더링 때 반영된다",
    "option3": "updated 훅 이후에만 반영된다",
    "option4": "DOM에는 절대 반영되지 않는다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "템플릿에서 v-bind 축약형으로 올바른 것은?",
    "option1": ":title=\"msg\"",
    "option2": ".bind(title)=\"msg\"",
    "option3": "@bind:title=\"msg\"",
    "option4": "#title=\"msg\"",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "v-on:click=\"count++\" 구문이 예상대로 동작하려면 count는 어디에 있어야 하는가?",
    "option1": "data()가 반환하는 객체",
    "option2": "methods 안",
    "option3": "computed 안",
    "option4": "watch 안",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 인스턴스 옵션 중 필수가 아닌 것은?",
    "option1": "methods",
    "option2": "data",
    "option3": "el / mount 대상",
    "option4": "template 또는 render",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "Vue 반응형 시스템의 핵심 개념은?",
    "option1": "데이터 변경 ↔ DOM 자동 동기화",
    "option2": "가상 DOM을 직접 조작",
    "option3": "양방향 바인딩 없는 단방향 흐름",
    "option4": "DOM 변화를 수동으로 감지",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "계산된 속성(computed)의 특징은?",
    "option1": "의존 데이터가 변할 때만 재평가",
    "option2": "무조건 매 렌더링마다 실행",
    "option3": "DOM 이벤트 발생 시에만 실행",
    "option4": "블로킹 I/O를 자동 회피",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "Vue 3에서 ref(0)으로 반환되는 값의 내부 형식은?",
    "option1": "객체 { value: 0 } (Proxied)",
    "option2": "Proxy 함수",
    "option3": "숫자 0 그 자체",
    "option4": "WeakMap",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watch와 computed의 주요 차이점으로 올바른 것은?",
    "option1": "watch는 부수 효과(side-effect) 실행용",
    "option2": "watch는 캐싱된 결과를 반환",
    "option3": "computed는 비동기 호출만 지원",
    "option4": "computed는 의존성 추적을 하지 않음",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "reactive()에 전달해도 반응형이 되지 않는 값은?",
    "option1": "Map 또는 Set",
    "option2": "평범한 Object",
    "option3": "배열(Array)",
    "option4": "중첩 객체가 없는 null-free 리터럴",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "DOM 갱신 후 실행하려면 다음 코드 뒤에 무엇을 해야 하는가? count.value++;",
    "option1": "await nextTick() 뒤에 console.log 실행",
    "option2": "flushSync()로 감싼다",
    "option3": "watchEffect 안에서 실행",
    "option4": "count.value += 0 으로 강제 트리거",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "Vue 3 반응형 시스템이 Vue 2의 defineProperty 대신 사용하는 기술은?",
    "option1": "ES6 Proxy",
    "option2": "MutationObserver",
    "option3": "WeakRef",
    "option4": "Reflect.metadata",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "shallowReactive()를 사용할 때의 이점은?",
    "option1": "루트 레벨만 반응형으로 만들어 메모리·성능 절약",
    "option2": "깊은 중첩 객체까지 자동 추적",
    "option3": "ref와 동일한 API 제공",
    "option4": "Computed 속성을 자동 생성",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watch 구성에서 deep:true, immediate:true가 비효율적인 경우는?",
    "option1": "변경 폭이 큰 대용량 중첩 객체를 감시",
    "option2": "원시형(ref) 값을 감시",
    "option3": "deep 옵션 false",
    "option4": "immediate false",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watchEffect가 watch보다 적합한 상황은?",
    "option1": "의존 대상을 명시하기 힘든 복합 반응형 로직",
    "option2": "특정 하나의 ref 변경에만 반응",
    "option3": "비동기 API 호출 후 에러 처리",
    "option4": "props 유효성 검증",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "요소를 조건부로 렌더링하기 위한 기본 디렉티브는?",
    "option1": "v-if",
    "option2": "v-for",
    "option3": "v-bind",
    "option4": "v-html",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "리스트 렌더링에 사용하는 디렉티브는?",
    "option1": "v-for",
    "option2": "v-show",
    "option3": "v-model",
    "option4": "v-once",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "양방향 폼 바인딩을 제공하는 디렉티브는?",
    "option1": "v-model",
    "option2": "v-text",
    "option3": "v-pre",
    "option4": "v-slot",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-show 디렉티브의 특징으로 올바른 것은?",
    "option1": "DOM을 한 번만 렌더링하고 display 속성을 토글",
    "option2": "조건이 false면 노드를 아예 생성하지 않는다",
    "option3": "렌더 비용이 v-if보다 높다",
    "option4": "서버 사이드 렌더링에서만 사용된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-bind .camel 수식어 기능은?",
    "option1": "kebab-case 속성명을 camelCase로 변환",
    "option2": "문자열 값을 자동으로 number로 변환",
    "option3": "HTML을 이스케이프하지 않고 출력",
    "option4": "true 값을 전달하면 속성을 제거",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "mounted 훅은 언제 호출되는가?",
    "option1": "DOM 삽입 직후 최초 한 번",
    "option2": "updated 훅 직후",
    "option3": "컴포넌트 생성 직후",
    "option4": "beforeUnmount 직전",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트 제거 직전에 호출되는 훅은?",
    "option1": "beforeUnmount",
    "option2": "unmounted",
    "option3": "beforeUpdate",
    "option4": "errorCaptured",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "Composition API에서 DOM 삽입 후 실행 훅 등록 함수는?",
    "option1": "onMounted",
    "option2": "onBeforeMount",
    "option3": "useMounted",
    "option4": "setupMounted",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-on .capture 수식어 역할은?",
    "option1": "이벤트를 캡처 단계에서 처리",
    "option2": "이벤트 버블링 중단",
    "option3": "수신 이벤트를 상위로 전파",
    "option4": "리스너를 한 번만 실행",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "@keyup.enter 수식어 의미는?",
    "option1": "Enter 키가 눌렸을 때만 keyup 핸들러 실행",
    "option2": "keyup 이벤트 캡처 단계",
    "option3": "Enter 키 아닌 경우 전파 중단",
    "option4": "keydown 이벤트 변환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "부모 → 자식 데이터 전달 메커니즘은?",
    "option1": "props",
    "option2": "slots",
    "option3": "provide/inject",
    "option4": "$refs",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "자식이 부모에게 값을 전달할 때 호출하는 메서드는?",
    "option1": "$emit",
    "option2": "$dispatch",
    "option3": "$broadcast",
    "option4": "$send",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "기본(이름 없는) 슬롯 태그는?",
    "option1": "<slot>",
    "option2": "<slot name=\"default\">",
    "option3": "<template #default>",
    "option4": "<slot-default>",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "props 타입 유효성 검사 키는?",
    "option1": "type",
    "option2": "validator",
    "option3": "required",
    "option4": "default",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "전역 컴포넌트 등록 API는?",
    "option1": "app.component()",
    "option2": "Vue.use()",
    "option3": "defineComponent()",
    "option4": "createRenderer()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "스코프드 슬롯 템플릿 축약은?",
    "option1": "<template #item=\"slotProps\">",
    "option2": "<slot name=\"item\" :slotProps>",
    "option3": "<slot v-bind=\"item\">",
    "option4": "<template v-slot:itemProps>",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "prop 값을 직접 변경 시 결과는?",
    "option1": "Vue가 경고 출력, 변경은 반응형 아님",
    "option2": "부모 원본 데이터 즉시 변경",
    "option3": "변경 허용되나 반응성 깨짐",
    "option4": "런타임 에러 발생",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "Composition API 자식이 v-model 지원하려면 emit 이벤트는?",
    "option1": "update:modelValue",
    "option2": "modelValue",
    "option3": "input",
    "option4": "change:model",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "provide/inject 값을 반응형 유지하려면?",
    "option1": "reactive() 또는 ref()로 래핑한 값 제공",
    "option2": "원시 값 제공",
    "option3": "JSON 직렬화",
    "option4": "watchEffect 반환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "슬롯 설명 중 틀린 것은?",
    "option1": "슬롯 콘텐츠는 부모 범위에서 컴파일",
    "option2": "동일 컴포넌트 슬롯 이름은 유일",
    "option3": "fallback 콘텐츠는 슬롯 비어 있을 때 표시",
    "option4": "스코프드 슬롯에서 자식→부모 데이터",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "Vue Router 동적 세그먼트 문법은?",
    "option1": "/users/:id",
    "option2": "/users/{id}",
    "option3": "/users/<id>",
    "option4": "/users/*id",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Pinia 스토어 정의 함수는?",
    "option1": "defineStore",
    "option2": "createStore",
    "option3": "useStore",
    "option4": "initializeStore",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "라우터 링크 컴포넌트는?",
    "option1": "<RouterLink>",
    "option2": "<RouterView>",
    "option3": "<LinkTo>",
    "option4": "<RouteLink>",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "setup 내 current route 얻기 방법은?",
    "option1": "const route = useRoute()",
    "option2": "const route = this.$route",
    "option3": "import { route } from 'vue-router'",
    "option4": "const route = getCurrentRoute()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Pinia actions에서 비동기 함수 정의 추가 설정은?",
    "option1": "별도 설정 없이 async/await 사용",
    "option2": "defineAsyncActions 플러그인",
    "option3": "setupStore 옵션 true",
    "option4": "store.$enableAsync() 호출",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Composition API 의존성 주입 함수 쌍은?",
    "option1": "provide / inject",
    "option2": "export / import",
    "option3": "emit / on",
    "option4": "dispatch / commit",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "history 모드 배포 시 서버 설정 주의?",
    "option1": "모든 경로를 index.html로 우회",
    "option2": "404 캐싱",
    "option3": "gzip 사용 금지",
    "option4": "URL에 .html 확장자",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "storeToRefs() 사용 이유는?",
    "option1": "state 속성을 ref로 분해해 반응형 링크 유지",
    "option2": "actions 자동 바인딩",
    "option3": "스토어 영속화",
    "option4": "게터 비동기 변환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "onBeforeRouteLeave 호출 안 되는 경우는?",
    "option1": "같은 경로, 쿼리만 변경",
    "option2": "다른 컴포넌트 네비게이션",
    "option3": "router.replace('/')",
    "option4": "브라우저 뒤로 가기",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "SSR에서 클라이언트 전용 코드 안전 실행 방법?",
    "option1": "if (typeof window !== 'undefined') { ... }",
    "option2": "onServerPrefetch 후 실행",
    "option3": "await useSSRContext()",
    "option4": "provide('client', true)",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  }
]