[
  {
    "question": "SQL에서 실행 계획을 분석할 수 있도록 해주는 명령어는?",
    "option1": "SHOW CREATE TABLE",
    "option2": "EXPLAIN",
    "option3": "DESCRIBE",
    "option4": "ANALYZE",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "SQL 옵티마이저(Optimizer)의 역할은 무엇인가?",
    "option1": "데이터 백업",
    "option2": "최적 실행 계획 선택",
    "option3": "스키마 정리",
    "option4": "사용자 인증",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "SELECT * 대신 컬럼을 명시하는 것이 성능에 좋은 이유는?",
    "option1": "트랜잭션 보호",
    "option2": "데이터 무결성 보장",
    "option3": "불필요한 데이터 조회 방지",
    "option4": "쿼리 결과를 암호화",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 SQL 실행 순서가 올바른 것은?",
    "option1": "SELECT → FROM → WHERE",
    "option2": "FROM → WHERE → SELECT",
    "option3": "WHERE → SELECT → FROM",
    "option4": "GROUP BY → FROM → SELECT",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 실행 계획에서 'Full Table Scan'이 발생하는 이유가 아닌 것은?",
    "option1": "인덱스가 없음",
    "option2": "WHERE 조건이 항상 TRUE",
    "option3": "ORDER BY가 존재함",
    "option4": "함수 적용된 WHERE 조건",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "오라클의 실행 계획 도구인 'AUTOTRACE'의 기능은?",
    "option1": "인덱스 생성",
    "option2": "쿼리 결과 수정",
    "option3": "실행 계획과 통계 정보 제공",
    "option4": "데이터를 외부로 내보냄",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 옵티마이저가 쿼리 실행 계획을 세울 때 고려하지 않는 요소는?",
    "option1": "테이블 통계 정보",
    "option2": "인덱스 존재 여부",
    "option3": "서버의 RAM 용량",
    "option4": "조인 방식",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "쿼리 튜닝 시 옵티마이저 힌트(Hint)의 역할은?",
    "option1": "쿼리 실행을 차단함",
    "option2": "테이블을 삭제함",
    "option3": "옵티마이저에게 힌트를 제공하여 실행 방식을 유도함",
    "option4": "SQL 구문을 자동 완성함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Cost-Based Optimizer(CBO)의 특징은?",
    "option1": "하드코딩된 규칙만 사용",
    "option2": "쿼리 구조만 고려",
    "option3": "통계 정보를 기반으로 비용을 계산함",
    "option4": "항상 빠른 쿼리를 선택함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "실행 계획에서 Nested Loop Join은 어떤 상황에서 적합한가?",
    "option1": "두 테이블 모두 대용량일 때",
    "option2": "조인 대상이 모두 인덱스일 때",
    "option3": "정렬이 필요한 경우",
    "option4": "서브쿼리가 있을 때",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "SQL 성능 이해",
    "chapterNum": 1
  },
  {
    "question": "인덱스를 사용하면 가장 크게 기대할 수 있는 효과는?",
    "option1": "데이터 보안 강화",
    "option2": "데이터 중복 제거",
    "option3": "조회 성능 향상",
    "option4": "스토리지 감소",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 RDB에서 가장 일반적으로 사용되는 인덱스 구조는?",
    "option1": "B-Tree",
    "option2": "해시맵",
    "option3": "Linked List",
    "option4": "R-Tree",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "WHERE 절에 사용되는 컬럼에 인덱스를 걸면 좋은 이유는?",
    "option1": "쿼리 실행 순서를 바꾸기 위해",
    "option2": "GROUP BY 연산을 빠르게 하려고",
    "option3": "조건 검색 속도를 향상시키기 위해",
    "option4": "트랜잭션을 줄이기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 인덱스를 사용해도 효과가 떨어지는 상황은?",
    "option1": "LIKE ‘A%’ 조건",
    "option2": "정렬된 숫자 검색",
    "option3": "범위 조건 사용",
    "option4": "LIKE ‘%A’ 조건",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "복합 인덱스 A, B가 있을 때 A만 WHERE 조건에 쓰면?",
    "option1": "인덱스 사용 안 됨",
    "option2": "효과적으로 인덱스 사용됨",
    "option3": "에러 발생",
    "option4": "인덱스를 무조건 재구성해야 함",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "해시 인덱스는 어떤 작업에 적합한가?",
    "option1": "범위 검색",
    "option2": "정렬",
    "option3": "정확한 키 검색",
    "option4": "JOIN 연산",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "Covering Index의 주요 특징은?",
    "option1": "모든 값을 복사해 저장",
    "option2": "인덱스만으로 결과를 반환할 수 있음",
    "option3": "쓰기 성능이 향상됨",
    "option4": "컬럼 순서를 무시함",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 인덱스 사용률을 높이는 SQL 스타일은?",
    "option1": "함수 안에 컬럼을 넣기",
    "option2": "가공된 값을 조건으로 비교",
    "option3": "컬럼 그대로 WHERE 절에서 사용",
    "option4": "DISTINCT를 다수 사용",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 클러스터형 인덱스(Clustered Index)에 대한 설명으로 옳은 것은?",
    "option1": "데이터 정렬과 무관하게 저장",
    "option2": "인덱스가 따로 존재하며 별도로 관리됨",
    "option3": "데이터 자체가 인덱스 구조로 정렬됨",
    "option4": "조회 시 항상 느리다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 인덱스를 사용하는데 가장 방해가 되는 요소는?",
    "option1": "ORDER BY 절",
    "option2": "GROUP BY 절",
    "option3": "WHERE 조건에 함수 사용",
    "option4": "LIMIT 절",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인덱스와 데이터 접근 방식",
    "chapterNum": 2
  },
  {
    "question": "다음 중 쿼리 성능을 가장 직접적으로 향상시킬 수 있는 작업은?",
    "option1": "SELECT * 사용",
    "option2": "인덱스 설계",
    "option3": "JOIN 순서 무작위 변경",
    "option4": "쿼리 이름 지정",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "서브쿼리를 사용했을 때의 단점은?",
    "option1": "가독성 향상",
    "option2": "성능 저하 가능성",
    "option3": "데이터 정합성 증가",
    "option4": "보안 강화",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 쿼리 리팩토링의 효과가 아닌 것은?",
    "option1": "유지보수 편의성 향상",
    "option2": "결과 정확도 감소",
    "option3": "성능 향상 가능성",
    "option4": "가독성 향상",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 INNER JOIN과 성능 차이가 가장 클 수 있는 JOIN 방식은?",
    "option1": "LEFT JOIN",
    "option2": "RIGHT JOIN",
    "option3": "OUTER JOIN",
    "option4": "SELF JOIN",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 LIMIT 구문의 사용 목적은?",
    "option1": "테이블 잠금",
    "option2": "결과 데이터의 수 제한",
    "option3": "데이터 중복 제거",
    "option4": "쿼리 실행 중지",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 COUNT(*)의 성능 개선 방법으로 적절한 것은?",
    "option1": "서브쿼리로 COUNT 분리",
    "option2": "WHERE 조건 제거",
    "option3": "별도 통계 테이블 유지",
    "option4": "DISTINCT 사용",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 인덱스를 사용하지 못하도록 만드는 조건은?",
    "option1": "WHERE id = 10",
    "option2": "WHERE name LIKE 'A%'",
    "option3": "WHERE UPPER(name) = 'A'",
    "option4": "WHERE age BETWEEN 20 AND 30",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 서브쿼리를 JOIN으로 바꾸는 이유로 적절하지 않은 것은?",
    "option1": "결과 정확도 향상",
    "option2": "성능 향상",
    "option3": "가독성 향상",
    "option4": "옵티마이저의 최적화 가능성 증가",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 EXISTS와 IN의 주요 차이는?",
    "option1": "EXISTS는 정렬함", 
    "option2": "IN은 항상 빠름", 
    "option3": "EXISTS는 조건 만족 시 바로 종료함", 
    "option4": "IN은 조건을 하나씩 수행함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "다음 중 성능 테스트 시 주의할 점으로 옳지 않은 것은?",
    "option1": "캐시 초기화 상태 확인",
    "option2": "데이터량에 따른 실행 시간 측정",
    "option3": "최초 실행 시간만 기준으로 판단",
    "option4": "실행 계획 비교",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "쿼리 튜닝 전략",
    "chapterNum": 3
  },
  {
    "question": "정규화의 주요 목적은 무엇인가?",
    "option1": "데이터 중복 증가",
    "option2": "데이터 정렬",
    "option3": "데이터 무결성 유지",
    "option4": "조회 성능 저하",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "1NF(제1정규형)의 핵심 조건은?",
    "option1": "모든 컬럼은 기본 키에 종속되어야 함",
    "option2": "원자값만 저장",
    "option3": "이행적 종속 제거",
    "option4": "다대다 관계 제거",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "2NF를 만족하려면 무엇을 제거해야 하는가?",
    "option1": "부분적 함수 종속",
    "option2": "이행적 종속",
    "option3": "후보 키",
    "option4": "기본 키",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "제3정규형(3NF)은 어떤 종속을 제거하는가?",
    "option1": "부분 종속",
    "option2": "이행적 종속",
    "option3": "다치 종속",
    "option4": "후보키 종속",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "다음 중 정규화를 적용했을 때 기대되는 효과는?",
    "option1": "데이터 정합성 저하",
    "option2": "쿼리 복잡도 감소",
    "option3": "데이터 중복 감소",
    "option4": "성능 저하",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "정규화된 테이블을 비정규화할 때의 이점은?",
    "option1": "관리 복잡도 증가",
    "option2": "관계도 증가",
    "option3": "조회 성능 향상",
    "option4": "정합성 강화",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "다음 중 비정규화의 단점은?",
    "option1": "데이터 중복 증가",
    "option2": "정규화보다 더 많은 테이블",
    "option3": "조회 성능 저하",
    "option4": "무결성 자동 보장",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "정규화와 비정규화를 결정할 때 가장 중요하게 고려해야 할 것은?",
    "option1": "쿼리 최적화 방식",
    "option2": "시스템의 메모리 크기",
    "option3": "데이터 정합성과 성능의 균형",
    "option4": "트리거 개수",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "BCNF는 어떤 상황에서 필요해지는가?",
    "option1": "3NF보다 더 높은 무결성이 필요할 때",
    "option2": "2NF를 만족할 때",
    "option3": "모든 키가 기본 키일 때",
    "option4": "후보 키가 하나일 때",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "다음 중 정규화된 모델보다 비정규화된 모델이 유리한 경우는?",
    "option1": "데이터 변경이 자주 일어날 때",
    "option2": "데이터 정합성이 가장 중요할 때",
    "option3": "읽기 성능이 매우 중요할 때",
    "option4": "데이터 중복을 피해야 할 때",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "정규화와 비정규화",
    "chapterNum": 4
  },
  {
    "question": "다음 중 데이터베이스 성능 저하의 일반적인 원인은?",
    "option1": "정규화 완료",
    "option2": "인덱스 과다 사용",
    "option3": "인덱스 미사용",
    "option4": "쿼리 캐시 사용",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "DB 서버에 병목 현상이 발생하는 주요 원인이 아닌 것은?",
    "option1": "디스크 I/O 과다",
    "option2": "네트워크 지연",
    "option3": "불필요한 인덱스 제거",
    "option4": "동시 접속 증가",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "실시간으로 대용량 데이터를 빠르게 처리하고자 할 때 적절한 전략은?",
    "option1": "정규화 수행",
    "option2": "비정규화 및 파티셔닝",
    "option3": "뷰(view) 사용",
    "option4": "모든 데이터를 캐싱",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "수직 파티셔닝은 어떤 기준으로 테이블을 나누는가?",
    "option1": "행(Row)",
    "option2": "컬럼(Column)",
    "option3": "데이터 타입",
    "option4": "사용자 그룹",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "데이터를 파티셔닝하는 주요 목적은?",
    "option1": "데이터 정렬",
    "option2": "보안 향상",
    "option3": "성능 향상 및 확장성 확보",
    "option4": "데이터 중복",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "다음 중 파티셔닝을 적용하기 좋은 상황은?",
    "option1": "소규모 정적 데이터 처리",
    "option2": "읽기보다 쓰기가 많은 데이터",
    "option3": "시간에 따라 분리되는 대용량 로그",
    "option4": "서브쿼리 많은 상황",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "데이터베이스 성능 모니터링 도구가 수집하지 않는 정보는?",
    "option1": "CPU 사용률",
    "option2": "네트워크 대역폭",
    "option3": "쿼리 실행 시간",
    "option4": "개발자 수",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "실시간 대시보드에서 성능을 높이기 위한 전략은?",
    "option1": "정규화된 테이블 조인",
    "option2": "최소 쿼리 요청, 캐시 활용",
    "option3": "모든 쿼리 서버 측 실행",
    "option4": "복잡한 집계 로직 도입",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "읽기 부하가 큰 서비스에서 효과적인 구조는?",
    "option1": "쓰기 전용 인스턴스",
    "option2": "읽기 전용 복제본(Read Replica) 구성",
    "option3": "트리거 사용 증가",
    "option4": "정규화 강화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  },
  {
    "question": "분산 DB 시스템에서 데이터 일관성보다 가용성을 우선할 때의 전략은?",
    "option1": "CAP 중 C 보장",
    "option2": "ACID 보장 강화",
    "option3": "Eventually Consistent 모델 사용",
    "option4": "동기식 복제만 사용",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "실무 성능 이슈 및 해결 사례",
    "chapterNum": 5
  }

]
