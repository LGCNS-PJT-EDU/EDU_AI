[
  {
    "question": "Spring Boot에서 Kotlin을 사용할 때 가장 기본이 되는 클래스 선언 방식은?",
    "option1": "public static void main",
    "option2": "fun main(args: Array<String>)",
    "option3": "startApp(args: List<String>)",
    "option4": "main(args: String[])",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Kotlin에서 Bean 주입을 생성자 방식으로 처리하기 위해 사용하는 키워드는?",
    "option1": "open",
    "option2": "init",
    "option3": "constructor",
    "option4": "val",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring Boot 애플리케이션의 진입점 클래스에 필요한 애노테이션은?",
    "option1": "@EnableSpring",
    "option2": "@SpringBootApplication",
    "option3": "@RestApp",
    "option4": "@AutoScan",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 Kotlin을 사용할 때 자주 마주치는 특징은?",
    "option1": "변수는 반드시 null 가능해야 함",
    "option2": "모든 클래스는 추상 클래스여야 함",
    "option3": "기본적으로 모든 변수는 non-null로 설계됨",
    "option4": "클래스 이름은 대문자로 시작할 수 없음",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 Kotlin을 사용할 때 생성자에 `val` 또는 `var` 키워드를 붙이는 이유는?",
    "option1": "자동으로 Bean으로 등록되기 위해",
    "option2": "클래스 내부에 멤버 변수로 선언되기 위해",
    "option3": "코드가 Java로 변환되기 위해",
    "option4": "데이터 클래스로 강제되기 위해",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 Kotlin을 사용할 때 클래스에 반드시 필요한 키워드는?",
    "option1": "abstract",
    "option2": "open",
    "option3": "final",
    "option4": "static",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Kotlin 기반 Spring 애플리케이션에서 Component Scan 대상은 기본적으로 어디부터 시작되는가?",
    "option1": "src/main/kotlin/",
    "option2": "프로젝트 루트 디렉토리",
    "option3": "@SpringBootApplication이 위치한 패키지 이하",
    "option4": "resource 폴더 경로 기준",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring Boot에서 Kotlin의 `data class`를 Bean으로 사용할 때 주의할 점은?",
    "option1": "기본 생성자를 가지지 않아야 함",
    "option2": "모든 필드는 반드시 null 허용해야 함",
    "option3": "필드를 val로 선언하면 변경이 불가하므로 의도에 맞게 설계해야 함",
    "option4": "data class는 Bean으로 등록되지 않음",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Spring과 Kotlin을 함께 사용할 때 DI가 실패할 수 있는 상황은?",
    "option1": "클래스가 open으로 선언되지 않음",
    "option2": "생성자에 val을 쓰지 않음",
    "option3": "Kotlin 버전이 1.3 이상일 때",
    "option4": "패키지 명이 중복될 때",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring Boot에서 Kotlin을 사용할 때 자주 사용하는 확장 함수 개념을 잘 설명한 것은?",
    "option1": "외부 클래스에 메서드를 추가하는 방식으로 재정의 가능",
    "option2": "스프링 빈에 직접 주입되는 메서드",
    "option3": "모든 메서드가 오버라이딩되는 것",
    "option4": "코루틴과 함께 작동할 수 없음",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Kotlin과 Spring Boot의 통합 기초",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 REST API를 만들 때 Kotlin과 함께 가장 기본적으로 사용하는 애노테이션은?",
    "option1": "@Controller",
    "option2": "@Service",
    "option3": "@RestController",
    "option4": "@Bean",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Kotlin에서 GET 요청을 처리할 때 사용하는 애노테이션은?",
    "option1": "@PostMapping",
    "option2": "@GetMapping",
    "option3": "@RequestBody",
    "option4": "@PutMapping",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Spring에서 `@RequestParam`은 어떤 경우에 사용되는가?",
    "option1": "JSON Body 파싱",
    "option2": "쿼리 파라미터 추출",
    "option3": "경로 변수 추출",
    "option4": "파일 업로드 처리",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "경로 변수(`/users/{id}`)를 추출하기 위해 사용하는 애노테이션은?",
    "option1": "@RequestParam",
    "option2": "@PathVariable",
    "option3": "@Param",
    "option4": "@RequestBody",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Spring에서 요청 본문(JSON 등)을 객체로 변환할 때 사용하는 애노테이션은?",
    "option1": "@RequestParam",
    "option2": "@PathVariable",
    "option3": "@RequestBody",
    "option4": "@Inject",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Kotlin DSL 스타일의 라우팅 처리를 가장 잘 설명한 것은?",
    "option1": "조건문 기반으로 라우팅을 전환한다",
    "option2": "함수형 스타일로 HTTP 경로를 정의한다",
    "option3": "동적으로 컨트롤러를 주입한다",
    "option4": "데이터 클래스를 동적으로 생성한다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Spring에서 Kotlin DSL을 통해 라우터를 정의할 때 사용하는 함수는?",
    "option1": "route()",
    "option2": "router { }",
    "option3": "mapping()",
    "option4": "controller { }",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Kotlin에서 컨트롤러 메서드 반환 타입으로 가장 흔히 사용되는 것은?",
    "option1": "View",
    "option2": "String",
    "option3": "ResponseEntity<T>",
    "option4": "Any",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Kotlin과 Spring을 함께 사용할 때 유효성 검사를 위해 사용하는 애노테이션은?",
    "option1": "@Valid",
    "option2": "@Validated",
    "option3": "@Check",
    "option4": "@Verify",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Spring Boot와 Kotlin 조합에서 경량 라우팅 처리를 위한 라이브러리는?",
    "option1": "RestAssured",
    "option2": "Spring WebFlux",
    "option3": "Ktor",
    "option4": "SpringWebMVC.kt",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Kotlin 스타일의 컨트롤러 & 라우팅 설계",
    "chapterNum": 2
  },
  {
    "question": "Spring에서 Kotlin으로 서비스 계층 클래스를 정의할 때 자주 사용하는 애노테이션은?",
    "option1": "@Repository",
    "option2": "@Service",
    "option3": "@Component",
    "option4": "@Entity",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Kotlin에서 생성자 기반 의존성 주입을 쉽게 하려면 어떤 접근 방식을 사용하는가?",
    "option1": "lateinit var + @Autowired",
    "option2": "생성자에 파라미터 추가 + constructor",
    "option3": "기본 생성자와 setter 조합",
    "option4": "생성자 내부에서 @Inject 사용",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Service 클래스에서 예외를 던지고 싶을 때 사용하는 Kotlin 키워드는?",
    "option1": "catch",
    "option2": "throw",
    "option3": "raise",
    "option4": "fail",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Kotlin에서는 사용자 정의 예외 클래스를 생성할 때 상속해야 하는 클래스는?",
    "option1": "RuntimeException",
    "option2": "Exception",
    "option3": "Throwable",
    "option4": "IllegalStateException",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "다음 중 Kotlin답게 null을 활용한 예외 처리를 위한 구문은?",
    "option1": "if (obj == null) throw Exception()",
    "option2": "obj ?: throw IllegalArgumentException()",
    "option3": "when (obj) { null -> throw }",
    "option4": "obj?.run { } ?: fail()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Spring에서 전역 예외 처리용 클래스를 만들 때 사용하는 애노테이션은?",
    "option1": "@ErrorHandler",
    "option2": "@ExceptionMapper",
    "option3": "@ControllerAdvice",
    "option4": "@GlobalError",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "@ExceptionHandler 애노테이션은 어떤 용도로 사용하는가?",
    "option1": "로그 기록",
    "option2": "요청 DTO 검증",
    "option3": "특정 예외 발생 시 처리 로직 실행",
    "option4": "정상 응답 반환",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Kotlin에서 sealed class를 예외 처리에 활용할 수 있는 이유는?",
    "option1": "무조건 에러가 발생하기 때문",
    "option2": "서브 클래스의 종류가 제한되어 패턴 매칭이 가능하기 때문",
    "option3": "코드를 간결하게 만들기 때문",
    "option4": "오직 싱글톤으로만 동작하기 때문",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Service 계층 테스트 시 Mock 객체를 만들기 위해 사용되는 Kotlin 라이브러리는?",
    "option1": "Mockito",
    "option2": "Kotest",
    "option3": "Kluent",
    "option4": "MockK",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "서비스 계층에서 여러 예외 케이스를 명확히 나누고자 할 때 가장 Kotlin스러운 방법은?",
    "option1": "Exception 메시지를 문자열로 다르게 줌",
    "option2": "RuntimeException만 사용",
    "option3": "sealed class로 예외 분기 + when으로 처리",
    "option4": "로그에 예외를 분기해서 기록",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Kotlin 기반의 서비스 계층 설계 및 예외 처리",
    "chapterNum": 3
  },
  {
    "question": "Kotlin에서 JPA Entity 클래스를 정의할 때 가장 중요한 키워드는?",
    "option1": "@Bean",
    "option2": "@Component",
    "option3": "@Entity",
    "option4": "@Table",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "JPA에서 Entity 클래스에 반드시 선언해야 하는 필드는?",
    "option1": "String name",
    "option2": "val type",
    "option3": "Primary constructor",
    "option4": "식별자 필드(@Id)",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "Kotlin의 `val` 필드로 선언된 Entity 속성의 주의점은?",
    "option1": "수정이 불가능하여 setter가 생성되지 않음",
    "option2": "자동으로 데이터베이스와 동기화됨",
    "option3": "엔티티 매핑이 자동으로 생략됨",
    "option4": "모든 필드가 nullable이 됨",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "JPA에서 엔티티 필드가 `null`을 허용하도록 하려면 Kotlin에서 어떤 문법을 사용하는가?",
    "option1": "lateinit",
    "option2": "nullsafe",
    "option3": "?",
    "option4": "!!",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "Kotlin에서 JPA를 사용할 때 `data class`를 피해야 하는 이유는?",
    "option1": "자동 생성된 equals/hashCode가 프록시 객체와 충돌할 수 있음",
    "option2": "모든 필드가 자동으로 final이 되기 때문",
    "option3": "JPA는 data class를 지원하지 않기 때문",
    "option4": "data class는 Bean으로 등록되지 않기 때문",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "엔티티 클래스가 `open` 키워드를 가져야 하는 주된 이유는?",
    "option1": "Spring DevTools와 호환되기 위해",
    "option2": "JPA가 프록시 생성을 위해 런타임에 상속 구조를 사용하기 때문",
    "option3": "엔티티를 View에 노출하기 위해",
    "option4": "모든 Bean이 open이어야 하기 때문",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "JPA에서 `@GeneratedValue`는 어떤 역할을 하는가?",
    "option1": "필드에 기본값을 설정",
    "option2": "ID 값을 자동으로 생성",
    "option3": "엔티티를 자동으로 저장",
    "option4": "Entity를 불변으로 만듦",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "코틀린에서 지연 로딩(LAZY)을 사용할 때 발생할 수 있는 문제는?",
    "option1": "자동 저장 누락",
    "option2": "코루틴과 충돌",
    "option3": "프록시 초기화 시 NPE 발생 가능성",
    "option4": "동시성 충돌",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Kotlin에서 JPA Entity를 작성할 때 권장되지 않는 설계 방식은?",
    "option1": "기본 생성자 제공",
    "option2": "생성자 파라미터를 모두 val로 고정",
    "option3": "nullable 필드에 기본값 설정",
    "option4": "엔티티 클래스에 open 키워드 사용",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "Spring Boot에서 JPA를 Kotlin과 함께 사용할 때 필수적인 gradle 플러그인은?",
    "option1": "kotlin-android",
    "option2": "spring-boot-jpa",
    "option3": "kotlin-jpa",
    "option4": "kotlin-allopen",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "코틀린 JPA와 엔티티 설계 시 고려할 점",
    "chapterNum": 4
  },
  {
    "question": "Kotlin에서 코루틴을 선언하기 위해 사용하는 키워드는?",
    "option1": "launch",
    "option2": "async",
    "option3": "suspend",
    "option4": "thread",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "Spring에서 Kotlin 코루틴을 지원하기 위한 종속성은?",
    "option1": "spring-boot-starter-reactor",
    "option2": "spring-kotlin-coroutines",
    "option3": "spring-boot-starter-webflux",
    "option4": "spring-coroutines-support",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "`@Async`를 사용하면 Spring에서 어떤 처리를 할 수 있는가?",
    "option1": "자동으로 캐싱한다",
    "option2": "비동기적으로 메서드를 실행한다",
    "option3": "코루틴을 자동 생성한다",
    "option4": "애플리케이션을 종료한다",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "코루틴에서 `Deferred<T>`는 무엇을 의미하는가?",
    "option1": "비동기 흐름을 끊는 객체",
    "option2": "Thread 대신 사용하는 객체",
    "option3": "비동기 작업의 결과를 담는 약속(Promise)",
    "option4": "예외를 모니터링하는 객체",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "Spring WebFlux와 코루틴을 함께 사용할 때 가장 적합한 반환 타입은?",
    "option1": "Deferred<T>",
    "option2": "ResponseEntity<T>",
    "option3": "Mono<T>",
    "option4": "suspend fun",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "Kotlin 코루틴에서 I/O 작업에 최적화된 Dispatcher는?",
    "option1": "Dispatchers.Default",
    "option2": "Dispatchers.Main",
    "option3": "Dispatchers.IO",
    "option4": "Dispatchers.Unconfined",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "Spring에서 `@EnableAsync`를 선언하지 않으면?",
    "option1": "스프링 컨테이너가 실행되지 않는다",
    "option2": "코루틴이 중단된다",
    "option3": "`@Async`가 무시된다",
    "option4": "DI가 실패한다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "Kotlin에서 비동기 흐름을 선언적으로 구성할 수 있는 라이브러리는?",
    "option1": "Ktor",
    "option2": "RxJava",
    "option3": "Flow",
    "option4": "Stream",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "suspend 함수 내에서 다른 suspend 함수를 호출할 수 있는 이유는?",
    "option1": "컴파일 타임 최적화 때문",
    "option2": "동시에 실행되기 때문",
    "option3": "코루틴 컨텍스트를 공유하기 때문",
    "option4": "suspend 함수는 블로킹을 허용하기 때문",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  },
  {
    "question": "다음 중 Spring + Kotlin 비동기 처리에서 피해야 할 잘못된 조합은?",
    "option1": "suspend fun + WebClient",
    "option2": "suspend fun + ResponseEntity",
    "option3": "suspend fun + @Async",
    "option4": "suspend fun + Flow",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "비동기 흐름과 코루틴을 활용한 API 처리",
    "chapterNum": 5
  }
]