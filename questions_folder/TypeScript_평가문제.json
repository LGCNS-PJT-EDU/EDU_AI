[
  {
    "question": "다음 선언에서 변수 greeting 의 타입은?\nlet greeting: string = \"hello\";",
    "option1": "string",
    "option2": "any",
    "option3": "String (래퍼 객체)",
    "option4": "never",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "number[] 타입과 완전히 같은 의미를 갖는 배열 선언은?",
    "option1": "Array<number>",
    "option2": "ReadonlyArray<number>",
    "option3": "Array<any>",
    "option4": "boolean[]",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "타입 단언(as)을 올바르게 사용한 예시는?",
    "option1": "const el = document.getElementById(\"app\") as HTMLDivElement;",
    "option2": "const num = \"3\" as number[];",
    "option3": "const flag = (true) as never;",
    "option4": "let v = 1; v as;",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "unknown 과 any 의 차이에 대한 설명 중 옳은 것은?",
    "option1": "unknown 값은 사용 전 타입 좁히기(narrowing)가 필요하다",
    "option2": "any 값은 컴파일 단계에서 아무 연산도 허용되지 않는다",
    "option3": "unknown 은 런타임에만 존재하는 타입이다",
    "option4": "any 로 선언된 변수는 자동으로 never 로 업캐스트된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "다음 함수의 반환 타입으로 가장 적절한 것은?\nfunction fail(msg: string) { throw new Error(msg); }",
    "option1": "never",
    "option2": "void",
    "option3": "undefined",
    "option4": "unknown",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "enum Color { Red, Green, Blue } 선언에서 Color.Green 의 값은?",
    "option1": 1,
    "option2": 0,
    "option3": "\"Green\"",
    "option4": "undefined",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "다음 중 튜플 타입을 올바르게 선언한 것은?",
    "option1": "let point: [number, number] = [1, 2];",
    "option2": "let point: (number, number) = 1, 2;",
    "option3": "let point = [number, number];",
    "option4": "let point: number[] = [1, \"2\"];",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "const assertion을 활용해 모든 프로퍼티를 읽기 전용 리터럴로 만드는 예시는?\nconst cfg = _____;",
    "option1": "{ mode: \"dark\" } as const",
    "option2": "as const { mode: \"dark\" }",
    "option3": "{ mode: \"dark\" } as readonly",
    "option4": "const { mode: \"dark\" }",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "다음 코드에서 Keys 타입은 무엇이 되는가?\nenum E { A, B, C } type Keys = keyof typeof E;",
    "option1": "\"A\" | \"B\" | \"C\"",
    "option2": "0 | 1 | 2",
    "option3": "E",
    "option4": "keyof E (컴파일 오류)",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "const str = \"hello\"; 변수 str 의 타입 추론 결과는?",
    "option1": "\"hello\" (리터럴 타입)",
    "option2": "string",
    "option3": "any",
    "option4": "never",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "기본 타입 · 타입 단언 & 타입 추론",
    "chapterNum": 1
  },
  {
    "question": "다음 화살표 함수에서 TypeScript가 추론한 반환 타입은?\nconst add = (a: number, b: number) => a + b;",
    "option1": "number",
    "option2": "void",
    "option3": "any",
    "option4": "never",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "‘나머지 매개변수’(rest parameter)를 올바르게 선언한 예시는?",
    "option1": "function sum(...nums: number[]): number { /*...*/ }",
    "option2": "function sum(nums...: number): number { /*...*/ }",
    "option3": "function sum(..nums: number[]): number { /*...*/ }",
    "option4": "function sum(nums:number) ...rest { /*...*/ }",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "다음 함수 호출 시 컴파일 오류가 발생하지 않도록 하려면 f에 필요한 오버로드 시그니처는?\nf(\"hi\"); f(1, 2);",
    "option1": "function f(str: string): void; function f(a: number, b: number): void;",
    "option2": "function f(arg: string | number): void;",
    "option3": "function f(...args: any[]): void;",
    "option4": "function f(str: string, num: number): void;",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "제네릭 함수 identity<T>(value: T): T 를 호출한 결과의 타입은?\nconst x = identity<string>(\"abc\");",
    "option1": "string",
    "option2": "T",
    "option3": "any",
    "option4": "void",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "제네릭 제약(Constraint)을 올바르게 사용한 예시는?",
    "option1": "function logLength<T extends { length: number }>(arg: T): number { return arg.length; }",
    "option2": "function logLength<T = { length: number }>(arg: T): number { return arg.length; }",
    "option3": "function logLength<T super { length: number }>(arg: T): number { return arg.length; }",
    "option4": "function logLength<T implements Lengthable>(arg: T): number { return arg.length; }",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "`this` 매개변수 타입을 명시해 오류를 방지한 올바른 선언은?",
    "option1": "function handler(this: void, e: Event): void { /*...*/ }",
    "option2": "function handler(e: Event, this): void { /*...*/ }",
    "option3": "function handler(this Event, e): void { /*...*/ }",
    "option4": "function handler(e: Event): this { /*...*/ }",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "다음 코드에서 T의 기본 타입 매개변수가 string이 되도록 올바른 선언은?",
    "option1": "function wrap<T = string>(value?: T): T[] { return [value as T]; }",
    "option2": "function wrap<T extends string>(value: T = \"\"): T[] { return [value]; }",
    "option3": "function wrap<T defaults string>(value?: T): T[] { return [value]; }",
    "option4": "function wrap<T string>(value?: T): T[] { return [value]; }",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "TypeScript 함수 오버로드에서 ‘구현부(implementation)’에 대해 옳은 설명은?",
    "option1": "선언된 여러 시그니처 뒤에 단 하나만 존재해야 한다",
    "option2": "오버로드마다 구현을 따로 작성해야 한다",
    "option3": "구현부의 매개변수는 반드시 any 타입이어야 한다",
    "option4": "구현부는 export 되어서는 안 된다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "다음 함수는 왜 컴파일 오류가 나는가?\nfunction foo(a?: number, b: number) {}",
    "option1": "선택 매개변수는 필수 매개변수 뒤에 올 수 없다",
    "option2": "number 타입에는 선택 여부를 지정할 수 없다",
    "option3": "void 반환형을 명시하지 않았다",
    "option4": "매개변수가 두 개 이상이면 반드시 rest 사용",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "다음 제네릭 함수에서 T가 string | number 일 때 반환 타입은?\nfunction toArray<T>(value: T): T[] { return [value]; }",
    "option1": "(string | number)[]",
    "option2": "string[] | number[]",
    "option3": "never[]",
    "option4": "any[]",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "함수 · 제네릭 & 오버로드",
    "chapterNum": 2
  },
  {
    "question": "다음 중 인터페이스 선언으로 올바른 것은?",
    "option1": "interface User { id: number; name?: string }",
    "option2": "interface = User { id number; }",
    "option3": "type interface User = { id: number }",
    "option4": "interface User: { id; number }",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "타입 별칭으로 제네릭을 선언할 때 올바른 문법은?",
    "option1": "type Box<T> = { value: T };",
    "option2": "alias Box<T> { value: T }",
    "option3": "type<T> Box = { value: T }",
    "option4": "typedef Box<T> = { value: T };",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "`type Keys = keyof { a: string; b: number }` 의 결과는?",
    "option1": "\"a\" | \"b\"",
    "option2": "string | number",
    "option3": "\"a\" & \"b\"",
    "option4": "any",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "인터섹션 타입 A & B 에 대한 설명으로 옳은 것은?",
    "option1": "A 와 B 모두의 프로퍼티를 가진 타입이다",
    "option2": "A 와 B 중 하나를 선택한 유니언이다",
    "option3": "런타임에 자동으로 객체를 병합한다",
    "option4": "중복 프로퍼티가 있으면 never 타입이 된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "다음 유니언 타입을 차별화(discriminated) 하기 위한 공통 프로퍼티는?",
    "option1": "kind",
    "option2": "length",
    "option3": "value",
    "option4": "type",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "다음 매핑된 타입 선언의 효과는?\ntype Readonly<T> = { readonly [K in keyof T]: T[K] };",
    "option1": "모든 프로퍼티를 readonly 로 만든다",
    "option2": "모든 프로퍼티를 선택적(optional)으로 만든다",
    "option3": "프로퍼티를 제거한다",
    "option4": "함수 타입으로 변환한다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "조건부 타입 T extends string ? string : number 에서 T가 boolean일 때 평가 결과는?",
    "option1": "number",
    "option2": "string",
    "option3": "boolean",
    "option4": "never",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "분배 조건부 타입에서 never가 결과로 나오지 않도록 하려면 사용하는 래퍼(Wrapper) 기법은?",
    "option1": "튜플로 감싸기 `[T]`",
    "option2": "Partial<T> 적용",
    "option3": "keyof T 사용",
    "option4": "as const 단언",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "다음 인터페이스가 있을 때 Optional<T> 의 역할은?\ninterface User { id: number; name: string } type Optional<T> = { [K in keyof T]?: T[K] };",
    "option1": "모든 프로퍼티를 선택적으로 만든다",
    "option2": "모든 프로퍼티를 필수로 만든다",
    "option3": "프로퍼티 key를 union 으로 반환",
    "option4": "T 타입을 조건부 타입으로 변환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "다음 인덱스 시그니처 선언의 의미는?\ninterface StringMap { [key: string]: string }",
    "option1": "임의의 문자열 키에 대해 값은 string 이어야 한다",
    "option2": "키와 값이 항상 같은 문자열이다",
    "option3": "숫자 인덱스 전용 객체이다",
    "option4": "키는 리터럴 타입만 허용한다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인터페이스 · 타입 별칭 & 고급 타입",
    "chapterNum": 3
  },
  {
    "question": "다음 클래스 선언에서 명시적으로 접근 제한자를 생략한 name 필드의 기본 접근 수준은?",
    "option1": "public",
    "option2": "private",
    "option3": "protected",
    "option4": "readonly",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "readonly 프로퍼티는 어디에서만 값을 할당(변경)할 수 있는가?",
    "option1": "선언과 동시에 또는 생성자 내부",
    "option2": "어디서든 한 번만",
    "option3": "클래스 외부 아무 곳",
    "option4": "정적 메서드 내부",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "다음 코드가 컴파일 오류를 일으키는 이유는?\nabstract class Base {} const b = new Base();",
    "option1": "abstract 클래스는 직접 인스턴스화할 수 없다",
    "option2": "Base 클래스에 constructor가 없다",
    "option3": "extends 키워드가 필요하다",
    "option4": "타입 매개변수가 누락됐다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "클래스 멤버 데코레이터를 사용하려면 tsconfig에 설정해야 하는 Compiler 옵션은?",
    "option1": "\"experimentalDecorators\": true",
    "option2": "\"emitDecoratorMetadata\": false",
    "option3": "\"useDecorators\": true",
    "option4": "\"strict\": false",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "다음 코드 중 매개변수 프로퍼티(Parameter Property)를 이용한 예시는?",
    "option1": "constructor(private id: number, public name: string)",
    "option2": "id!: number;",
    "option3": "public getId() { return this.id }",
    "option4": "static from(obj: any) { ... }",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "protected 멤버에 대한 설명으로 틀린 것은?",
    "option1": "동일 클래스 내부에서 접근 가능하다",
    "option2": "파생(하위) 클래스 내부에서 접근 가능하다",
    "option3": "클래스 인스턴스 외부에서 접근 가능하다",
    "option4": "인스턴스 외부에서는 접근 불가하다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "모듈 시스템에서 모든 내보내기를 객체 하나로 가져오는 올바른 구문은?",
    "option1": "import * as utils from \"./utils\";",
    "option2": "import utils.* from \"./utils\";",
    "option3": "import { * } from \"utils\";",
    "option4": "require(\"./utils\") as *",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "static 멤버에 대한 올바른 접근 방법은?\nclass Counter { static total = 0; }",
    "option1": "Counter.total",
    "option2": "new Counter().total",
    "option3": "Counter.prototype.total",
    "option4": "this.total",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "클래스 데코레이터 함수의 첫 번째 매개변수 타입은?",
    "option1": "생성자 함수를 나타내는 (new (...args: any[]) => any)",
    "option2": "인스턴스 타입",
    "option3": "string",
    "option4": "PropertyDescriptor",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "다음 import 구문이 기본값과 이름 내보내기를 동시에 가져오는 정확한 형태는?",
    "option1": "import def, { named } from \"./mod\";",
    "option2": "import { default as def, named } from \"./mod\";",
    "option3": "import * as def, named from \"./mod\";",
    "option4": "import def, named from \"mod\";",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "클래스 · 모듈 · 데코레이터 & 접근 제한자",
    "chapterNum": 4
  },
  {
    "question": "다음 조건부 타입에서 T가 string | number 일 때 Inferred 타입은?\ntype Inferred<T> = T extends string ? 1 : 0;",
    "option1": "1 | 0",
    "option2": "never",
    "option3": "1",
    "option4": "0",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "유틸리티 타입 Partial<T> 의 효과는?",
    "option1": "T의 모든 프로퍼티를 선택적(optional)으로 만든다",
    "option2": "T의 모든 프로퍼티를 읽기 전용으로 만든다",
    "option3": "T의 프로퍼티를 제거한다",
    "option4": "T를 never 로 변환한다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "다음 제네릭에서 infer U 로 추론되는 타입 U는?\ntype ElementType<T> = T extends (infer U)[] ? U : T;",
    "option1": "배열의 요소 타입",
    "option2": "배열 자체 타입",
    "option3": "never",
    "option4": "unknown",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "`NonNullable<T>` 유틸리티 타입은 어떤 멤버를 제거하는가?",
    "option1": "null 과 undefined",
    "option2": "void",
    "option3": "never",
    "option4": "0 과 \"\"",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "다음 매핑된 타입에서 `-?` 기호의 의미는?\ntype Req<T> = { [K in keyof T]-?: T[K] };",
    "option1": "선택적(?) 속성 한정자를 제거해 필수로 만든다",
    "option2": "readonly 한정자를 제거한다",
    "option3": "프로퍼티 키를 제거한다",
    "option4": "Union 타입을 분배한다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "Exclude<\"a\" | \"b\", \"a\"> 의 결과 타입은?",
    "option1": "\"b\"",
    "option2": "\"a\"",
    "option3": "\"a\" | \"b\"",
    "option4": "never",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "다음 타입에서 infer R 은 무엇을 추론하는가?\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;",
    "option1": "함수 반환 타입",
    "option2": "함수 매개변수 타입",
    "option3": "함수 this 타입",
    "option4": "함수 호출 시그니처 개수",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "`Pick<T, K>` 유틸리티 타입 사용 시 K 의 제약은?",
    "option1": "keyof T 에 속하는 프로퍼티 key union 이어야 한다",
    "option2": "아무 Union 타입 가능",
    "option3": "number 만 가능",
    "option4": "T 의 값 타입이 포함되어야 한다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "다음 조건부 타입에서 infer 키워드가 필요한 이유는?\ntype First<T extends any[]> = T extends [infer F, ...any] ? F : never;",
    "option1": "배열의 첫 요소 타입을 추론하기 위해",
    "option2": "배열 길이를 체크하기 위해",
    "option3": "프로미스 결과를 기다리기 위해",
    "option4": "제네릭 제약을 제거하기 위해",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  },
  {
    "question": "다음 타입 정의에서 readonly와 optional을 동시에 제거하려면 어떤 유틸리티 조합이 필요한가?\ntype Clean<T> = ____<____<T>>;",
    "option1": "Required & Mutable (커스텀 Mutable 구현 필요)",
    "option2": "NonNullable & Exclude",
    "option3": "Pick & Omit",
    "option4": "Partial & Readonly",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 제네릭 · 조건부 타입 & 유틸리티 타입",
    "chapterNum": 5
  }
]