[
  {
    "question": "Spring Data JPA에서 Kotlin 데이터를 엔티티로 선언할 때 가장 적절한 키워드는?",
    "option1": "open class",
    "option2": "sealed class",
    "option3": "object",
    "option4": "data class",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "Kotlin에서 JPA를 사용할 때 반드시 class를 open으로 선언하는 이유는?",
    "option1": "컴파일 최적화를 위해",
    "option2": "Spring Boot에서 자동으로 열어주기 때문",
    "option3": "프록시 생성을 위해 상속이 가능해야 하기 때문",
    "option4": "코드의 가독성을 높이기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "JPA에서 Kotlin의 data class를 엔티티로 직접 사용하지 않는 주된 이유는?",
    "option1": "생성자 파라미터가 자동 인식되지 않아서",
    "option2": "Spring과 호환되지 않아서",
    "option3": "직렬화가 불가능해서",
    "option4": "toString(), equals() 등이 자동 생성되어 문제가 생기기 쉬워서",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "QueryDSL을 Kotlin에서 사용하기 위해 필요한 추가 도구는?",
    "option1": "KSP 또는 kapt를 통한 Q 클래스 생성",
    "option2": "Spring Security 설정",
    "option3": "Swagger 플러그인",
    "option4": "Coroutine Dispatcher",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "QueryDSL의 Q타입 클래스는 어떤 방식으로 생성되는가?",
    "option1": "런타임 리플렉션",
    "option2": "JVM 컴파일러 자동 생성",
    "option3": "애노테이션 프로세서로 빌드 타임 생성",
    "option4": "IDE 내부 캐시",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "JPA에서 @Id가 붙은 필드는 어떤 역할을 하는가?",
    "option1": "로그 출력용",
    "option2": "DB에 저장되는 파일 경로를 의미",
    "option3": "기본 키로 사용되어 엔티티를 구분",
    "option4": "캐시 처리를 위한 식별자",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "Spring Data JPA에서 findByEmail 같은 메서드는 어떻게 동작하는가?",
    "option1": "런타임 시 매핑 정보에 따라 SQL이 직접 작성됨",
    "option2": "정적 HTML 문서를 생성",
    "option3": "서비스 레이어에 자동으로 주입됨",
    "option4": "정적 JSON 결과로 매핑",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "QueryDSL에서 where 절을 Kotlin DSL 스타일로 연결할 때 사용하는 연산자는?",
    "option1": "&&",
    "option2": "plus()",
    "option3": "and()",
    "option4": "infix between()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "Spring JPA에서 native query를 Kotlin에서 사용할 때의 주의점은?",
    "option1": "nullable 처리 및 매핑 오류 방지",
    "option2": "문자열 연결 방식 제한",
    "option3": "로그 출력이 불가능함",
    "option4": "캐시 저장 불가능",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },
  {
    "question": "Kotlin DSL 기반 QueryDSL의 가장 큰 장점은?",
    "option1": "네이티브 쿼리 속도 향상",
    "option2": "가독성 높은 코드와 타입 안정성",
    "option3": "자동 테이블 생성",
    "option4": "모든 JPA 설정 생략 가능",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Kotlin 기반 ORM 및 쿼리 도구",
    "chapterNum": 1
  },

  {
    "question": "Spring Security의 기본 동작 목적은?",
    "option1": "데이터 직렬화",
    "option2": "로그 포맷팅",
    "option3": "애플리케이션의 인증과 인가 처리",
    "option4": "SQL 최적화",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "JWT 토큰의 구성 요소로 올바른 것은?",
    "option1": "Payload.Header.Signature",
    "option2": "Token.Sign.Secret",
    "option3": "Header.Payload.Signature",
    "option4": "UserInfo.Token.Expiry",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Kotlin에서 Spring Security를 적용할 때 인증 정보를 가져오는 방식으로 가장 적절한 것은?",
    "option1": "SecurityContextHolder.getContext().authentication",
    "option2": "Thread.currentThread()",
    "option3": "ApplicationContext.getBean()",
    "option4": "Kotlin Reflection",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "JWT 토큰의 만료 시간을 설정하려면 어떤 claim을 사용해야 하는가?",
    "option1": "sub",
    "option2": "exp",
    "option3": "auth",
    "option4": "iss",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Kotlin DSL을 활용한 유효성 검증 코드에서 자주 사용되는 구조는?",
    "option1": "if-else 체인",
    "option2": "try-catch 반복",
    "option3": "require()와 check() 함수",
    "option4": "println() 기반 분기",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "javax.validation에서 문자열이 비어 있지 않아야 할 때 사용하는 어노테이션은?",
    "option1": "@Nullable",
    "option2": "@NotBlank",
    "option3": "@Max",
    "option4": "@NotEmpty",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Spring Security에서 권한을 설정할 때 사용되는 클래스는?",
    "option1": "HttpSecurity",
    "option2": "RestTemplate",
    "option3": "JwtEncoder",
    "option4": "DataBinder",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "JWT 기반 인증에서 토큰이 만료되었을 때 서버는 보통 어떻게 응답하는가?",
    "option1": "403 Forbidden",
    "option2": "200 OK",
    "option3": "302 Redirect",
    "option4": "401 Unauthorized",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Spring Security 설정 시 요청 경로에 대한 접근 제한은 어디서 설정하는가?",
    "option1": "application.yml",
    "option2": "SecurityFilterChain DSL 내부",
    "option3": "Controller 내부",
    "option4": "JWT Decoder",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Kotlin에서 사용자 입력에 대한 커스텀 유효성 검사를 구현하려면 어떤 인터페이스를 구현해야 하는가?",
    "option1": "Validator",
    "option2": "Checker",
    "option3": "RequestGuard",
    "option4": "FieldFilter",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 Validation 유틸",
    "chapterNum": 2
  },
  {
    "question": "Kotlin Coroutine의 가장 큰 장점 중 하나는?",
    "option1": "멀티 쓰레드를 강제로 사용",
    "option2": "비동기 작업을 직관적이고 선언적으로 작성 가능",
    "option3": "JVM에 직접 연동됨",
    "option4": "데이터베이스와만 사용됨",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "WebClient는 어떤 구조의 HTTP 요청 처리 방식인가?",
    "option1": "블로킹 방식",
    "option2": "동기식 처리",
    "option3": "논블로킹 방식",
    "option4": "모놀리식 통신",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "WebClient는 어떤 패키지에 포함되어 있는가?",
    "option1": "org.springframework.web.reactive.function.client",
    "option2": "java.net.http",
    "option3": "javax.servlet.client",
    "option4": "org.springframework.web.client.blocking",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "다음 중 Coroutine에서 비동기 작업을 실행하는 함수는?",
    "option1": "delay()",
    "option2": "launch{}",
    "option3": "async{}",
    "option4": "both launch{} and async{}",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "WebClient를 사용할 때 비동기 결과를 받기 위해 사용하는 리턴 타입은?",
    "option1": "String",
    "option2": "Deferred<T>",
    "option3": "Mono<T>",
    "option4": "FutureTask<T>",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "CoroutineScope를 명시적으로 지정하지 않고 사용하는 경우 어떤 문제가 발생할 수 있는가?",
    "option1": "성능 향상",
    "option2": "컴파일 에러",
    "option3": "코루틴 누수(leak) 발생",
    "option4": "JPA가 초기화되지 않음",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "WebClient 설정 시 요청 timeout 설정은 어디에 적용하는가?",
    "option1": "WebClient 기본 생성자",
    "option2": "HttpClient 옵션 설정",
    "option3": "BaseUrl 설정",
    "option4": "JPA Configuration",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "Coroutine에서 실행 중 예외가 발생하면?",
    "option1": "즉시 JVM이 종료된다",
    "option2": "모든 코루틴이 자동 정지된다",
    "option3": "해당 스코프 내 예외 처리 로직이 없으면 전파된다",
    "option4": "예외가 무시된다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "WebClient에서 헤더를 설정하려면 어떤 메서드를 사용하는가?",
    "option1": "addHeader()",
    "option2": "header()",
    "option3": "setHttpHeader()",
    "option4": "withHeaders()",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },
  {
    "question": "Kotlin Coroutine을 사용하여 서버 응답 시간을 줄이기 위해 자주 사용하는 키워드는?",
    "option1": "runBlocking",
    "option2": "withTimeout",
    "option3": "awaitClose",
    "option4": "yield",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "비동기 처리 및 웹 클라이언트 활용",
    "chapterNum": 3
  },

  {
    "question": "Springdoc-openapi의 주요 목적은?",
    "option1": "DB 연결을 자동화",
    "option2": "API 요청을 캐싱",
    "option3": "OpenAPI 3.0 명세 기반 문서 자동 생성",
    "option4": "로깅 레벨을 제어",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Swagger UI는 주로 어떤 기능을 제공하는가?",
    "option1": "API 서버 간 연동",
    "option2": "API를 시각적으로 테스트 및 문서화",
    "option3": "SQL 쿼리 튜닝",
    "option4": "애플리케이션 모니터링",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Kotlin Logging의 주요 특징은?",
    "option1": "JSP 로그만 지원",
    "option2": "Spring 전용 로깅 도구",
    "option3": "Kotlin에 최적화된 SLF4J 래퍼",
    "option4": "Logback의 경쟁 도구",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Spring Cache에서 사용되는 어노테이션은?",
    "option1": "@CachePut",
    "option2": "@CacheStore",
    "option3": "@EnableCache",
    "option4": "@StoreResult",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Redis의 가장 큰 장점은?",
    "option1": "파일 기반 처리",
    "option2": "오라클 DB 통합",
    "option3": "인메모리 기반 고속 캐시 시스템",
    "option4": "스레드 안전성 없음",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Spring Cache를 활성화하기 위한 설정은?",
    "option1": "@EnableTransactionManagement",
    "option2": "@EnableScheduling",
    "option3": "@EnableCaching",
    "option4": "@EnableRedis",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Kotlin에서 로그를 출력하려면 KotlinLogging을 사용해 어떤 객체를 선언하는가?",
    "option1": "val log = LoggerFactory.getLogger()",
    "option2": "val log = LogManager.getLogger()",
    "option3": "val log = KotlinLogging.logger {}",
    "option4": "val log = System.out",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Swagger에서 각 API 메서드를 설명할 때 사용하는 어노테이션은?",
    "option1": "@ApiMethod",
    "option2": "@Operation",
    "option3": "@ApiAction",
    "option4": "@Endpoint",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Spring Cache에서 조건부 캐시 적용 시 사용하는 속성은?",
    "option1": "unless",
    "option2": "conditionOnly",
    "option3": "onError",
    "option4": "setIf",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "다음 중 캐시 무효화를 위해 사용하는 어노테이션은?",
    "option1": "@CacheExpire",
    "option2": "@CacheInvalidate",
    "option3": "@CacheEvict",
    "option4": "@ClearCache",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "API 문서화, 로깅 및 캐시 유틸",
    "chapterNum": 4
  },
  {
    "question": "Kotlin에서 테스트를 위한 대표적인 라이브러리로 올바른 것은?",
    "option1": "SpringTools",
    "option2": "kotest",
    "option3": "Postman",
    "option4": "MockitoJVM",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "mockk 라이브러리의 특징은?",
    "option1": "자바 전용 목킹 라이브러리",
    "option2": "Spring Boot 전용 문서화 도구",
    "option3": "Kotlin에 최적화된 목(mock) 객체 생성 도구",
    "option4": "테스트 DB 자동 초기화 도구",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "JUnit5의 기본 어노테이션은?",
    "option1": "@TestCase",
    "option2": "@JUnitTest",
    "option3": "@RunTest",
    "option4": "@Test",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "Gradle Kotlin DSL의 빌드 스크립트 파일 확장자는?",
    "option1": ".gradlekts",
    "option2": ".kts",
    "option3": ".gradle",
    "option4": ".dslk",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "Dockerfile에서 애플리케이션 실행을 위한 명령어는?",
    "option1": "RUN",
    "option2": "EXPOSE",
    "option3": "CMD",
    "option4": "COPY",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "GitHub Actions의 주요 목적은?",
    "option1": "코드 스니펫 저장",
    "option2": "브랜치 병합 제한",
    "option3": "CI/CD 자동화 워크플로우 구성",
    "option4": "Slack 연동",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "JUnit5에서 테스트 전후 실행되는 어노테이션은?",
    "option1": "@BeforeEach / @AfterEach",
    "option2": "@RunBefore / @RunAfter",
    "option3": "@PreTest / @PostTest",
    "option4": "@Start / @Stop",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "mockk에서 특정 함수의 동작을 정의하려면 사용하는 함수는?",
    "option1": "runWith()",
    "option2": "given()",
    "option3": "every { ... }",
    "option4": "whenever()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "Docker 이미지 빌드를 위해 가장 먼저 작성하는 파일은?",
    "option1": "build.gradle.kts",
    "option2": "docker-compose.yml",
    "option3": "Dockerfile",
    "option4": "settings.gradle.kts",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  },
  {
    "question": "GitHub Actions에서 워크플로우 실행 조건을 설정하는 파일은?",
    "option1": "ci.yaml",
    "option2": ".workflow.yml",
    "option3": "main.yml",
    "option4": ".github/workflows/*.yml",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 배포 자동화 도구",
    "chapterNum": 5
  }




]
