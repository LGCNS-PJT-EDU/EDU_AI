[
  {
    "question": "Virtual DOM의 ‘가상’이 의미하는 것은?",
    "option1": "메모리에 존재하는 DOM 트리의 추상화 객체",
    "option2": "웹 GL로 그린 3D DOM",
    "option3": "브라우저 외부에서 렌더링된 서버 DOM",
    "option4": "CSS OM의 별칭",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "Virtual DOM을 가장 널리 보급한 라이브러리로 평가되는 것은?",
    "option1": "React",
    "option2": "AngularJS 1.x",
    "option3": "jQuery",
    "option4": "Backbone.js",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "Virtual DOM이 브라우저 DOM 직접 조작 대비 성능 이점을 주는 주된 이유는?",
    "option1": "여러 변경을 메모리상에서 모아 최소 패치로 적용하기 때문",
    "option2": "JS 파싱 시간을 없애기 때문",
    "option3": "CSS 계산을 스레드오프로드하기 때문",
    "option4": "네이티브 코드로 DOM API를 대체하기 때문",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "초기의 React(0.14 이전) 렌더 파이프라인 단계 순서는?",
    "option1": "Render→Diff→Patch",
    "option2": "Commit→Render→Diff",
    "option3": "Diff→Render→Mount",
    "option4": "Reflow→Paint→Diff",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "2014년 페이스북 논문 ‘Efficient Virtual DOM and Incremental DOM’에서 강조한 핵심 최적화 중 하나는?",
    "option1": "O(n) 키 기반 Diff",
    "option2": "CSS-in-JS 캐싱",
    "option3": "WebAssembly DOM 패치",
    "option4": "Service Worker 프리패치",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "Virtual DOM 개념이 React 외에도 채택된 경량 라이브러리로 유명한 것은?",
    "option1": "Snabbdom",
    "option2": "Ember.js",
    "option3": "Ext JS",
    "option4": "GWT",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "‘Virtual DOM은 무조건 실제 DOM 조작보다 빠르다’는 주장에 대한 올바른 반박은?",
    "option1": "계산·Diff 비용이 변경량보다 크면 실제 DOM이 더 빠를 수 있다",
    "option2": "브라우저가 Virtual DOM을 네이티브로 최적화하므로 항상 빠르다",
    "option3": "JS 엔진이 JIT 컴파일을 못하면 Virtual DOM이 강제된다",
    "option4": "HTML 문서 크기가 1 KB 미만이면 Virtual DOM이 필요 없다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "React 16 이상에서 Virtual DOM Fiber 아키텍처로 교체된 주된 목표는?",
    "option1": "작업을 잘게 쪼개 스케줄링해 인터랙션 응답성을 높이기 위해",
    "option2": "DOM API를 완전히 제거하기 위해",
    "option3": "JS Bundle 크기를 절반으로 줄이기 위해",
    "option4": "IE9 지원 유지 비용을 줄이기 위해",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "Virtual DOM 노드를 일반적으로 ‘VNode’라 부른다. 이 VNode가 직렬화·역직렬화에 적합한 이유는?",
    "option1": "순수 JS 객체로 사이드이펙트 없이 표현돼 JSON 변환이 쉽다",
    "option2": "DOM Node 인스턴스를 그대로 담기 때문이다",
    "option3": "HTML 문자열과 1:1 매핑되기 때문이다",
    "option4": "브라우저 IndexedDB에 자동 캐싱되기 때문이다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "Virtual DOM 탄생 이전 퍼포먼스 병목 개선 전통 기법은?",
    "option1": "DOM Batching(문서 조각·프래그먼트에 변경 누적 후 일괄 삽입)",
    "option2": "Web GPU 렌더링",
    "option3": "HTTP/3 PUSH",
    "option4": "SSR Streaming",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Virtual DOM 원리 & 역사",
    "chapterNum": 1
  },
  {
    "question": "React의 기본 Diff 전략이 O(n) 복잡도를 달성하는 핵심 전제는?",
    "option1": "같은 레벨(Depth)에서만 노드를 비교한다",
    "option2": "모든 형제 노드를 완전 탐색(DFS)한다",
    "option3": "HTML 태그 이름이 바뀌면 서브트리를 재귀 비교한다",
    "option4": "키가 중복될 때만 비교를 건너뛴다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "리스트 요소에 안정적 Key를 지정하지 않으면 발생할 수 있는 UI 문제는?",
    "option1": "입력‧포커스 상태가 잘못된 항목으로 이동한다",
    "option2": "DOM 노드가 절대로 재사용되지 않는다",
    "option3": "CSS 클래스가 적용되지 않는다",
    "option4": "브라우저 스크롤 위치가 고정된다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "아래 중 Key로 사용하기에 가장 안전한 값은?",
    "option1": "데이터베이스에서 보장된 고유 id",
    "option2": "배열 index",
    "option3": "Date.now() 호출 결과",
    "option4": "Math.random() 결과",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "Diff 과정에서 태그 이름이 다른 두 노드가 만나면 React는 어떻게 처리하는가?",
    "option1": "이전 노드를 언마운트하고 새 노드를 마운트한다",
    "option2": "텍스트 콘텐츠만 비교해 바꾼다",
    "option3": "속성을 깊이 비교해 바꾼다",
    "option4": "두 노드를 교환(Swap)한다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "형제 노드 순서 변경에 가장 큰 비용을 초래하는 Key 사용 패턴은?",
    "option1": "index를 Key로 사용",
    "option2": "고유 id를 Key로 사용",
    "option3": "문자열 해시를 Key로 사용",
    "option4": "숫자형 Primary Key 사용",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "React Diff에서 ‘삽입·삭제·이동’ 3연산을 줄이기 위해 적용되는 리스트 최적화는?",
    "option1": "Longest Increasing Subsequence(LIS) 탐색",
    "option2": "Binary Search Tree 재구성",
    "option3": "KMP 알고리즘",
    "option4": "Dijkstra",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "key=index 사용 시 버그 위험이 가장 높은 경우는?",
    "option1": "사용자가 Todo 항목을 드래그해 순서를 변경할 때",
    "option2": "초기 로딩 시 항목을 한 번만 표시할 때",
    "option3": "Todo가 읽기 전용일 때",
    "option4": "Todo 항목 수가 1개일 때",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "Diff 알고리즘 성능을 정성적으로 측정하기에 가장 적합한 지표는?",
    "option1": "렌더(Commit)당 DOM Mutation 개수",
    "option2": "JS Heap 스냅샷 크기",
    "option3": "네트워크 Bandwidth 사용량",
    "option4": "브라우저 FPS(Max)",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "React 18 Fiber 스케줄러가 Diff 작업을 중단할 수 있는 이유는?",
    "option1": "Fiber 노드를 작업 단위로 쪼개 cooperative scheduling 이 가능해서",
    "option2": "Virtual DOM을 Worker에서 실행하기 때문에",
    "option3": "Diff를 WASM으로",
    "option4": "Strict Mode 때문",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "Vue 3 PatchFlag 활용 목적은?",
    "option1": "변경 가능성 있는 부분만 빠르게 식별해 불필요한 비교를 줄이기 위해",
    "option2": "모든 노드를 깊이 비교하기 위해",
    "option3": "HTML 문자열 파싱 속도를 높이기 위해",
    "option4": "브라우저 GC 트리거 회피",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Diff 알고리즘 & 키의 역할",
    "chapterNum": 2
  },
  {
    "question": "React 18 렌더링 파이프라인의 기본 3단계 순서는?",
    "option1": "Render → Diff → Commit",
    "option2": "Commit → Render → Diff",
    "option3": "Diff → Commit → Render",
    "option4": "Prepare → Paint → Commit",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Scheduler가 중단·재개할 수 있는 단계는?",
    "option1": "Render(Diff) 단계",
    "option2": "Commit 단계",
    "option3": "브라우저 Paint 단계",
    "option4": "Layout 단계",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Batching은 여러 setState 호출을 어떻게 처리하는가?",
    "option1": "하나의 렌더 사이클로 합친다",
    "option2": "각 호출마다 즉시 렌더",
    "option3": "첫 호출만 실행",
    "option4": "setTimeout 지연",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Fiber 노드의 우선순위 필드는?",
    "option1": "lanes",
    "option2": "tag",
    "option3": "return",
    "option4": "index",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Concurrent Mode에서 긴 리스트 응답성 향상 API 조합은?",
    "option1": "startTransition / useTransition",
    "option2": "useLayoutEffect / flushSync",
    "option3": "useImperativeHandle / forwardRef",
    "option4": "unstable_batchedUpdates / act",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Commit 단계 직후 DOM 변경 확정 후 호출 훅은?",
    "option1": "useLayoutEffect / componentDidMount",
    "option2": "useEffect / componentDidUpdate",
    "option3": "getSnapshotBeforeUpdate",
    "option4": "shouldComponentUpdate",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Fiber 트리 alternate 포인터가 가리키는 것은?",
    "option1": "현재 트리와 작업 중 트리의 다른 하나",
    "option2": "부모 노드 sibling",
    "option3": "DevTools 메타",
    "option4": "Suspense fallback",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Suspense fallback 표시 시 Commit 단계 실제 동작은?",
    "option1": "기존 UI 유지, fallback 부분만 커밋",
    "option2": "전체 DOM 언마운트",
    "option3": "레이아웃 강제",
    "option4": "Fiber 루트 재생성",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "우선순위 동등 업데이트 합치기 정책은?",
    "option1": "가장 최근 업데이트만 남기고 합친다",
    "option2": "FIFO 렌더",
    "option3": "무작위 처리",
    "option4": "Deferred Value 생성",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "Offscreen 컴포넌트 렌더 시 Render 비용 줄이는 기술은?",
    "option1": "display locking 대신 메모리 트리만 유지",
    "option2": "Unmount",
    "option3": "Server Components",
    "option4": "lanes를 Idle",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리컨실리에이션(재조정) 사이클",
    "chapterNum": 3
  },
  {
    "question": "DOM 패치 단계의 1차 목표는?",
    "option1": "실제 DOM 변경을 최소 집합으로 적용해 레이아웃·페인트 비용을 줄인다",
    "option2": "가상 DOM 트리를 재귀적으로 깊이 비교한다",
    "option3": "JS 엔진 GC 주기를 단축한다",
    "option4": "HTTP 요청을 병렬화한다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "Layout 발생 트리거가 아닌 것은?",
    "option1": "읽기만 수행하는 element.getBoundingClientRect()",
    "option2": "style 변경",
    "option3": "노드 삭제",
    "option4": "innerHTML 교체",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "React style 속성 diff 전략은?",
    "option1": "바뀐 개별 CSS 프로퍼티만 set",
    "option2": "cssText 전체 재할당",
    "option3": "모두 null 후 재적용",
    "option4": "CSSOM 캐시 비움",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "Layout Thrashing 방지 일반 방법은?",
    "option1": "read와 write 작업을 일괄 모아 순서대로 실행",
    "option2": "모든 DOM 작업 setTimeout",
    "option3": "CSS will-change 남용",
    "option4": "MutationObserver 감시",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "innerHTML 교체가 효율적일 수 있는 시나리오는?",
    "option1": "컨텐츠 전체가 한 번에 완전히 교체되고 작을 때",
    "option2": "리스트 일부 텍스트 변경",
    "option3": "대규모 테이블 셀 일부 업데이트",
    "option4": "form value 변경",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "경량 VDOM class 속성 패치 전략은?",
    "option1": "이전·다음 클래스 토큰 비교해 add/remove",
    "option2": "className 전체 재지정",
    "option3": "classList.value 할당",
    "option4": "rAF 내 하나씩",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "React flushSync 이점은?",
    "option1": "동기 커밋으로 글리치 없이 연속 업데이트 묶는다",
    "option2": "Diff 건너뜀",
    "option3": "서버 컴포넌트 제외",
    "option4": "Worker 오프로드",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "배치되지 않은 setState 깜빡임 원리는?",
    "option1": "여러 Commit 분리로 Layout/Paint 각각",
    "option2": "GC 발생",
    "option3": "GPU 레이어 분리",
    "option4": "idleCallback",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "CSS contain 속성 활용 성능 개선 상황은?",
    "option1": "하위 레이아웃이 외부 영향 없을 때 contain 설정",
    "option2": "상위 Grid 퍼센트폭",
    "option3": "position fixed 요소",
    "option4": "z-index 충돌",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "SVG/Canvas 반복 갱신 시 대안은?",
    "option1": "WebGL/Canvas 직접 렌더",
    "option2": "innerHTML",
    "option3": "Shadow DOM",
    "option4": "Service Worker",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "실제 DOM 패치(Patching) 최적화",
    "chapterNum": 4
  },
  {
    "question": "Virtual DOM이 fine-grained 변경에 비효율적 이유는?",
    "option1": "전체 서브트리를 재평가·diff해야 해서",
    "option2": "GPU 가속 꺼짐",
    "option3": "HTML5 위배",
    "option4": "WASM 호환x",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "Svelte가 빠른 이유는?",
    "option1": "컴파일 단계 분석 후 직접 DOM 코드 생성",
    "option2": "모든 상태를 Proxy",
    "option3": "Service Worker 캐시",
    "option4": "WebGL 렌더",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "Incremental DOM 핵심 차이점은?",
    "option1": "Diff 없이 템플릿 실행 중 직접 DOM 명령 스트림",
    "option2": "키 불필요",
    "option3": "모든 노드 제거 후 삽입",
    "option4": "서버 전용",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "SolidJS 신호 패러다임 이점은?",
    "option1": "변경 DOM 바인딩만 다시 실행",
    "option2": "JSX 미사용",
    "option3": "Worker 렌더",
    "option4": "LocalStorage 캐싱",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "React Server Components가 줄여 주는 비용은?",
    "option1": "클라이언트 JS 번들 크기",
    "option2": "HTML 크기",
    "option3": "TLS 왕복",
    "option4": "브라우저 레이아웃",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "Resumability 목표는?",
    "option1": "Hydration 없이 서버 상태 이어받아 즉시 상호작용",
    "option2": "WebGL 모든 컴포넌트",
    "option3": "Worker 분산",
    "option4": "gRPC",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "Virtual DOM 필요 없는 이유(정적 콘텐츠 페이지)?",
    "option1": "변경 빈도 낮아 Diff 오버헤드 낭비",
    "option2": "브라우저가 VDOM 차단",
    "option3": "SSR HTML5 충돌",
    "option4": "SEO 스크립트 문제",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "React Forget 목표는?",
    "option1": "컴파일러로 fine-grained reactivity 자동 도입",
    "option2": "모든 useEffect 제거",
    "option3": "JSX 포팅",
    "option4": "webpack 제거",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "Astro Islands 아키텍처 방식은?",
    "option1": "필요 인터랙티브 부분만 CSR 하이드레이션",
    "option2": "페이지 전체 Shadow DOM",
    "option3": "defer 스크립트",
    "option4": "CSS inline",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  },
  {
    "question": "저사양 기기에서 VDOM 메모리 문제 이유는?",
    "option1": "VNode 트리가 추가 메모리 상주",
    "option2": "GPU 캐시 없음",
    "option3": "HTTP2 push",
    "option4": "Intl polyfill",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "한계·대안 & 최신 동향",
    "chapterNum": 5
  }
]