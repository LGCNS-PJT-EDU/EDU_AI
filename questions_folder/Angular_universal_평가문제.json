[
  {
    "question": "Angular Universal은 무엇을 위한 기술인가?",
    "option1": "모바일 앱 개발",
    "option2": "서버 사이드 렌더링(SSR)",
    "option3": "데스크탑 앱 개발",
    "option4": "PWA 개발",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal을 사용하면 얻을 수 없는 효과는?",
    "option1": "초기 로딩 속도 개선",
    "option2": "SEO 향상",
    "option3": "브라우저 캐시 제어",
    "option4": "서버 측 렌더링",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal의 핵심 모듈은?",
    "option1": "HttpClientModule",
    "option2": "ServerModule",
    "option3": "RouterModule",
    "option4": "FormsModule",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal이 필요한 주요 이유는?",
    "option1": "동적 데이터 바인딩",
    "option2": "서버 초기 페이지 제공",
    "option3": "라우팅 단순화",
    "option4": "API 구축",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Universal 렌더링의 기본 동작 방식은?",
    "option1": "클라이언트에서만 렌더링",
    "option2": "서버에서 HTML 생성 후 클라이언트로 전송",
    "option3": "SSR 후에도 HTML 미생성",
    "option4": "서버-클라이언트 양방향 바인딩",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal을 추가할 때 사용하는 CLI 명령어는?",
    "option1": "ng add @angular/ssr",
    "option2": "ng generate universal",
    "option3": "ng add universal",
    "option4": "ng install angular-server",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Universal 렌더링을 통해 특히 이점이 큰 앱은?",
    "option1": "채팅 앱",
    "option2": "SEO가 중요한 앱",
    "option3": "실시간 게임 앱",
    "option4": "데스크탑 앱",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal 프로젝트의 서버 진입점 파일은?",
    "option1": "main.ts",
    "option2": "server.ts",
    "option3": "index.ts",
    "option4": "app.module.ts",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal이 사용하는 서버 프레임워크는 주로 무엇인가?",
    "option1": "Spring",
    "option2": "Express",
    "option3": "Koa",
    "option4": "Django",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Universal 렌더링 후 Angular가 클라이언트에서 takeover 하는 과정을 무엇이라 부르는가?",
    "option1": "Rehydration",
    "option2": "Hydration",
    "option3": "Serialization",
    "option4": "Deserialization",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Angular Universal 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "Angular Universal을 프로젝트에 추가하는 CLI 명령어는?",
    "option1": "ng add @nguniversal/express-engine",
    "option2": "ng generate universal",
    "option3": "ng install universal",
    "option4": "ng build server",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "SSR을 활성화하면 Angular 프로젝트에 추가되는 서버 프레임워크는?",
    "option1": "NestJS",
    "option2": "Express",
    "option3": "Koa",
    "option4": "Fastify",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "SSR 빌드를 실행할 때 사용하는 명령어는?",
    "option1": "ng build",
    "option2": "ng run project-name:server",
    "option3": "npm run build:ssr",
    "option4": "ng start server",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "SSR 빌드 후 서버를 실행하는 명령어는?",
    "option1": "npm run dev:ssr",
    "option2": "npm start",
    "option3": "ng serve server",
    "option4": "ng deploy",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "Angular Universal이 생성하는 server.ts 파일의 역할은?",
    "option1": "라우팅 관리",
    "option2": "API 서버 구축",
    "option3": "서버 사이드 렌더링 핸들링",
    "option4": "컴포넌트 등록",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "SSR 빌드시 dist 폴더 내 서버 파일이 위치하는 기본 경로는?",
    "option1": "dist/server",
    "option2": "dist/browser",
    "option3": "dist/angular",
    "option4": "dist/universal",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "Angular Universal 프로젝트에서 서버 코드를 수정한 경우 필요한 작업은?",
    "option1": "브라우저 새로고침",
    "option2": "ng serve 재시작",
    "option3": "server build 재빌드",
    "option4": "ng lint",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "Angular Universal 서버는 기본적으로 어떤 포트에서 동작하는가?",
    "option1": "3000",
    "option2": "4000",
    "option3": "4200",
    "option4": "8080",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "Angular Universal 서버 코드에서 요청 객체를 받는 함수는?",
    "option1": "handleRequest()",
    "option2": "ngServer()",
    "option3": "ngExpressEngine()",
    "option4": "expressHandler()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "SSR 설정시 Angular AppServerModule은 어떤 역할을 하는가?",
    "option1": "API 서버 구성",
    "option2": "라우터 미들웨어 설정",
    "option3": "서버 사이드 렌더링 모듈 정의",
    "option4": "로그 기록",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "SSR 설정 및 빌드",
    "chapterNum": 2
  },
  {
    "question": "서버 측 렌더링(SSR) 흐름에서 가장 먼저 수행되는 것은?",
    "option1": "브라우저 렌더링",
    "option2": "서버 HTML 생성",
    "option3": "API 호출",
    "option4": "라우터 이동",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "Angular Universal 서버는 요청을 받으면 어떤 엔진을 호출하는가?",
    "option1": "renderEngine",
    "option2": "ngExpressEngine",
    "option3": "serverEngine",
    "option4": "htmlGenerator",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "SSR 처리 시 Angular가 렌더링을 완료하면 서버는 무엇을 클라이언트에 반환하는가?",
    "option1": "JSON 데이터",
    "option2": "Static Files",
    "option3": "HTML 페이지",
    "option4": "API 응답",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 사이드 렌더링에서 상태 동기화는 어느 과정에서 일어나는가?",
    "option1": "Hydration",
    "option2": "Serialization",
    "option3": "Navigation",
    "option4": "Injection",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 렌더링 중 API 요청을 막지 않고 처리하는 방법은?",
    "option1": "지연 렌더링",
    "option2": "transferState 사용",
    "option3": "streaming",
    "option4": "browserPreload",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버와 클라이언트 간 상태 전송을 위한 Angular 서비스는?",
    "option1": "TransferHttpCacheModule",
    "option2": "HttpClientModule",
    "option3": "ServerStateModule",
    "option4": "HydrationService",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 응답이 끝나기 전에 클라이언트가 초기화되는 것을 무엇이라 부르는가?",
    "option1": "Rehydration",
    "option2": "Preboot",
    "option3": "Prefetching",
    "option4": "ServerWait",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 사이드 렌더링 후 클라이언트가 takeover 하지 않으면 생기는 문제는?",
    "option1": "라우팅 실패",
    "option2": "SEO 실패",
    "option3": "앱이 비활성화 상태로 남음",
    "option4": "속도 저하",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 사이드 렌더링에서 preboot의 역할은?",
    "option1": "애니메이션 동기화",
    "option2": "초기 이벤트 기록",
    "option3": "라우터 히스토리 관리",
    "option4": "데이터베이스 연결",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "서버 측 렌더링 흐름에서 TransferState를 사용하는 주된 이유는?",
    "option1": "보안 강화",
    "option2": "API 요청 최소화",
    "option3": "렌더링 속도 향상",
    "option4": "라우터 최적화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "서버 측 렌더링 흐름 이해",
    "chapterNum": 3
  },
  {
    "question": "Angular Universal에서 라우팅은 주로 어디에서 처리되는가?",
    "option1": "클라이언트",
    "option2": "서버",
    "option3": "브라우저",
    "option4": "CDN",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "서버 측 라우팅을 위해 사용하는 Angular 모듈은?",
    "option1": "HttpClientModule",
    "option2": "ServerModule",
    "option3": "RouterModule",
    "option4": "UniversalModule",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "Angular SSR에서 라우트별 HTML 생성을 가능하게 하는 기능은?",
    "option1": "Static Rendering",
    "option2": "Prerendering",
    "option3": "Dynamic Routing",
    "option4": "Lazy Loading",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "Angular Universal 프로젝트에서 prefetch 데이터를 저장하는 방법은?",
    "option1": "sessionStorage",
    "option2": "localStorage",
    "option3": "TransferState",
    "option4": "Cookie",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "라우팅 이벤트를 감지하여 SSR 데이터 프리페칭을 수행하려면 무엇을 사용해야 하는가?",
    "option1": "ActivatedRoute",
    "option2": "Router Events",
    "option3": "NavigationEnd",
    "option4": "RouteGuard",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "라우트 기반 프리페칭 전략 중 잘못된 것은?",
    "option1": "Immediate Prefetching",
    "option2": "On-Demand Prefetching",
    "option3": "Preloading Strategy",
    "option4": "Delayed Loading",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "SSR을 통해 첫 페이지에 대해 얻을 수 있는 주요 이점은?",
    "option1": "클라이언트 부하 감소",
    "option2": "코드 난독화",
    "option3": "라우터 초기화 최소화",
    "option4": "CSS 최적화",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "데이터를 라우트마다 미리 가져오려면 Angular에서 무엇을 사용해야 하는가?",
    "option1": "Resolvers",
    "option2": "Guards",
    "option3": "Interceptors",
    "option4": "Pipes",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "서버에서 라우팅 시 발생할 수 있는 문제를 방지하기 위한 권장 방법은?",
    "option1": "라우터 Lazy Load 제거",
    "option2": "TransferState 활용",
    "option3": "HTTP 요청 차단",
    "option4": "RouterModule 제거",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "라우팅 시 데이터 프리페칭 최적화를 위해 사용하는 전략은?",
    "option1": "PreloadAllModules",
    "option2": "LazyLoadModules",
    "option3": "SyncLoadModules",
    "option4": "AllRoutesPrefetch",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅과 데이터 프리페칭",
    "chapterNum": 4
  },
  {
    "question": "SSR에서 초기 렌더링 후 클라이언트가 takeover하는 과정은 무엇이라 불리는가?",
    "option1": "Hydration",
    "option2": "Serialization",
    "option3": "Prefetching",
    "option4": "Rendering",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Angular Universal 앱의 성능 최적화를 위해 가장 권장되는 방법은?",
    "option1": "이미지 Lazy Loading",
    "option2": "모든 코드를 클라이언트에 동시 전송",
    "option3": "서버 캐시 비활성화",
    "option4": "브라우저 히스토리 비활성화",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Angular Universal 앱 배포 시 Node 서버와 함께 사용하는 서버는?",
    "option1": "Nginx",
    "option2": "Apache",
    "option3": "Express",
    "option4": "Spring Boot",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "SSR 페이지 캐싱을 통해 얻을 수 있는 주요 이점은?",
    "option1": "코드 경량화",
    "option2": "초기 응답 시간 단축",
    "option3": "CSS 최적화",
    "option4": "라우터 트래픽 감소",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Static SSR 페이지를 생성하는 Angular 명령어는?",
    "option1": "ng deploy",
    "option2": "ng prerender",
    "option3": "ng static",
    "option4": "ng build static",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "서버 캐시를 구현할 때 가장 많이 사용하는 미들웨어는?",
    "option1": "compression",
    "option2": "express-cache-controller",
    "option3": "helmet",
    "option4": "body-parser",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Angular Universal 앱에서 SEO를 향상시키기 위한 방법은?",
    "option1": "Canonical URL 설정",
    "option2": "CSS 최적화",
    "option3": "Lazy Loading 제거",
    "option4": "State 저장",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "SSR 시 TransferState의 주요 목적은?",
    "option1": "라우터 히스토리 저장",
    "option2": "서버와 클라이언트 간 데이터 공유",
    "option3": "서버 성능 향상",
    "option4": "미들웨어 로깅",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Static Generation과 SSR의 주요 차이점은?",
    "option1": "Static은 빌드 시 HTML 생성, SSR은 요청 시 생성",
    "option2": "SSR은 정적 파일만 생성",
    "option3": "Static은 항상 서버 필요",
    "option4": "SSR은 파일 시스템만 사용",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Angular Universal 배포시 서버 부하를 줄이기 위한 전략은?",
    "option1": "SSR 모든 요청 처리",
    "option2": "Static 페이지 최대한 활용",
    "option3": "SPA 모드 사용",
    "option4": "라우터 동기화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "고급 최적화 및 배포 전략",
    "chapterNum": 5
  }
]