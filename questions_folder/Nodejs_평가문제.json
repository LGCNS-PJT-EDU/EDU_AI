[
  {
    "question": "Node.js의 가장 큰 특징 중 하나는?",
    "option1": "스레드 기반 동기 처리",
    "option2": "JavaScript를 브라우저에서만 실행",
    "option3": "이벤트 기반 비동기 처리",
    "option4": "PHP 기반으로 동작",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Node.js에서 외부 패키지를 설치하고 관리할 수 있는 도구는?",
    "option1": "GIT",
    "option2": "NPM",
    "option3": "SQL",
    "option4": "VIM",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Node.js에서 모듈을 불러오는 문법으로 알맞은 것은?",
    "option1": "import.module('fs')",
    "option2": "require('fs')",
    "option3": "load('fs')",
    "option4": "get('fs')",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Node.js에서 비동기 처리를 가능하게 해주는 구조는?",
    "option1": "블로킹 큐",
    "option2": "멀티 스레드 큐",
    "option3": "이벤트 루프",
    "option4": "데이터 플로우 트리",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Node.js에서 파일 시스템 작업을 제공하는 내장 모듈은?",
    "option1": "net",
    "option2": "http",
    "option3": "os",
    "option4": "fs",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "npm init 명령어를 실행하면 생성되는 파일은?",
    "option1": "package.js",
    "option2": "server.json",
    "option3": "package.json",
    "option4": "config.yaml",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "require() 함수를 통해 불러온 모듈이 리턴하는 것은?",
    "option1": "HTML 파일",
    "option2": "라우팅 객체",
    "option3": "모듈에서 exports한 객체 또는 함수",
    "option4": "Java 클래스",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Node.js에서 동기 함수와 비교하여 비동기 함수의 장점은?",
    "option1": "코드 작성이 쉽다",
    "option2": "모든 요청을 직렬로 처리",
    "option3": "처리 속도가 느리다",
    "option4": "다수의 요청을 효율적으로 처리 가능",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "다음 중 CommonJS 방식의 모듈 정의법으로 옳은 것은?",
    "option1": "export default {}",
    "option2": "exports = {}",
    "option3": "module.exports = {}",
    "option4": "define(() => {})",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Node.js가 싱글 스레드임에도 고성능을 내는 이유는?",
    "option1": "코드를 순차적으로 실행하기 때문",
    "option2": "멀티 프로세스를 기본으로 하기 때문",
    "option3": "이벤트 루프와 비동기 처리를 통해 I/O 병목을 줄이기 때문",
    "option4": "매 요청마다 서버를 재시작하기 때문",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Node.js 기본 개념 및 실행 구조",
    "chapterNum": 1
  },
  {
    "question": "Express.js는 어떤 목적으로 사용되는 Node.js 프레임워크인가?",
    "option1": "데스크탑 애플리케이션 개발",
    "option2": "파일 시스템 처리",
    "option3": "웹 서버 및 API 구축",
    "option4": "CLI 툴 개발",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "Express에서 라우팅을 정의할 때 사용하는 메서드는?",
    "option1": "get(), post(), put(), delete()",
    "option2": "select(), update(), remove()",
    "option3": "listen(), connect(), init()",
    "option4": "path(), query(), route()",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "REST API 설계에서 'GET' 메서드는 어떤 목적에 사용되는가?",
    "option1": "데이터 생성",
    "option2": "데이터 삭제",
    "option3": "데이터 조회",
    "option4": "데이터 갱신",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "다음 중 RESTful URI 설계로 가장 적절한 것은?",
    "option1": "/getUserById?id=1",
    "option2": "/user?id=1",
    "option3": "/user/1",
    "option4": "/fetch/user/1",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "Express.js의 미들웨어는 언제 실행되는가?",
    "option1": "라우터가 실행된 후 결과를 보내기 전에",
    "option2": "서버가 시작되기 전에만",
    "option3": "라우터에 도달하지 않고 무조건 건너뜀",
    "option4": "응답을 브라우저에 보낸 후",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Express의 기본 구조에서 올바른 요청 처리 흐름은?",
    "option1": "Controller → Middleware → Route",
    "option2": "Route → Middleware → Response",
    "option3": "Request → Middleware → Route Handler → Response",
    "option4": "Middleware → DB → Controller",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Express에서 미들웨어를 정의하는 기본 문법은?",
    "option1": "app.route('/', callback)",
    "option2": "app.use((req, res, next) => {})",
    "option3": "app.get((req, res) => {})",
    "option4": "use.app((req, res, next) => {})",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "REST API의 리소스를 표현하는 올바른 방식은?",
    "option1": "동사 기반 URI",
    "option2": "복잡한 쿼리 문자열 중심",
    "option3": "명확한 명사 기반 URI",
    "option4": "HTML 태그 기반 URI",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "Express에서 에러 처리 미들웨어의 인자는 몇 개인가?",
    "option1": "2개",
    "option2": "3개",
    "option3": "4개",
    "option4": "5개",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },
  {
    "question": "REST API에서 PUT과 PATCH의 가장 큰 차이점은?",
    "option1": "둘 다 삭제 요청이다",
    "option2": "PUT은 전체 업데이트, PATCH는 일부 업데이트",
    "option3": "PATCH는 새 리소스 생성용이다",
    "option4": "PUT은 조회 요청이다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Express.js와 REST API 설계",
    "chapterNum": 2
  },

  {
    "question": "환경 변수 파일(.env)을 Node.js 프로젝트에서 사용할 수 있도록 도와주는 패키지는?",
    "option1": "config.js",
    "option2": "dotenv",
    "option3": "env-loader",
    "option4": "envParser",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "환경에 따라 설정을 분기 처리할 때 사용하는 Node.js 전역 변수는?",
    "option1": "NODE_MODE",
    "option2": "NODE_TYPE",
    "option3": "NODE_ENV",
    "option4": "ENV_STAGE",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "JWT의 구성 요소는 다음 중 어떤 형태인가?",
    "option1": "Header.Payload.Signature",
    "option2": "Key.Value.Secret",
    "option3": "Token.Passcode.ID",
    "option4": "UserID.Time.Secret",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "다음 중 Access Token과 Refresh Token을 동시에 사용하는 이유는?",
    "option1": "로그인을 두 번 하기 위해",
    "option2": "보안 강화를 위해 짧은 만료와 재발급 구조 분리",
    "option3": "속도 향상을 위해 캐싱 구조 사용",
    "option4": "프론트엔드와 연동을 단순화하기 위해",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "다음 중 전역 에러 처리 미들웨어에서 반드시 포함되어야 하는 인자 개수는?",
    "option1": "2",
    "option2": "3",
    "option3": "4",
    "option4": "5",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "유효성 검사 라이브러리인 express-validator에서 validationResult를 사용하는 목적은?",
    "option1": "DB 연결 확인",
    "option2": "JWT 토큰 파싱",
    "option3": "검증 실패 항목 추출",
    "option4": "라우터 매핑 처리",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "Joi 라이브러리의 주요 용도는?",
    "option1": "파일 시스템 접근",
    "option2": "환경 변수 주입",
    "option3": "데이터 유효성 스키마 기반 검사",
    "option4": "로그 기록",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "JWT 토큰을 검증할 때 필요한 값은?",
    "option1": "암호화 키 (Secret)",
    "option2": "사용자 비밀번호",
    "option3": "DB 연결 문자열",
    "option4": "Access ID",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "다음 중 전역 에러 핸들러가 처리하지 못하는 것은?",
    "option1": "라우팅 실패",
    "option2": "비동기 함수 내 throw 에러 (await 없이)",
    "option3": "express-validator 오류",
    "option4": "동기 실행 중 예외",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "HTTP 요청 시 인증이 필요한 API 라우터에 적용해야 하는 미들웨어의 역할은?",
    "option1": "로그를 기록한다",
    "option2": "데이터를 암호화한다",
    "option3": "JWT를 해석하고 유효한지 검증한다",
    "option4": "라우터 경로를 캐싱한다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인증, 환경 변수 및 에러 핸들링",
    "chapterNum": 3
  },
  {
    "question": "Mongoose는 어떤 데이터베이스를 위한 ODM(Object Document Mapper)인가?",
    "option1": "PostgreSQL",
    "option2": "MongoDB",
    "option3": "MySQL",
    "option4": "Redis",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Sequelize는 어떤 종류의 ORM인가?",
    "option1": "GraphQL 기반 ORM",
    "option2": "Document 기반 ORM",
    "option3": "SQL 기반 ORM",
    "option4": "파일 기반 ORM",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Prisma의 주요 특징으로 올바른 것은?",
    "option1": "MongoDB 전용 ORM",
    "option2": "SQL Schema 기반 타입 안전성 제공",
    "option3": "NoSQL 전용 쿼리만 지원",
    "option4": "테스트 도구와 통합 불가",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Postman의 주요 사용 목적은?",
    "option1": "JWT 암호화",
    "option2": "MongoDB 백업",
    "option3": "API 요청 시뮬레이션 및 테스트",
    "option4": "로컬 호스팅",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Mongoose에서 findOne() 함수의 역할은?",
    "option1": "모든 문서 삭제",
    "option2": "단일 문서를 검색",
    "option3": "컬렉션 생성",
    "option4": "스키마 정의",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Sequelize에서 테이블을 정의하기 위한 객체는?",
    "option1": "Client",
    "option2": "Schema",
    "option3": "Model",
    "option4": "Repository",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Prisma에서 DB 마이그레이션을 적용하기 위한 명령어는?",
    "option1": "npx prisma migrate deploy",
    "option2": "prisma update-db",
    "option3": "npm run sync-schema",
    "option4": "prisma reset",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Postman에서 변수 설정을 통해 얻을 수 있는 이점은?",
    "option1": "JWT 생성 자동화",
    "option2": "요청 경로와 파라미터 재사용성 향상",
    "option3": "데이터베이스 직접 수정",
    "option4": "브라우저에서 실행 가능",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "Jest 테스트 도구의 특징 중 하나는?",
    "option1": "HTML 테스트 전용",
    "option2": "Node.js 환경 전용 단위 테스트 지원",
    "option3": "Swagger UI 기반 실행",
    "option4": "MySQL 쿼리 전용 분석기",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "다음 중 통합 테스트에 적합한 도구는?",
    "option1": "supertest",
    "option2": "dotenv",
    "option3": "mongoose",
    "option4": "bcrypt",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "데이터베이스 연동 및 테스트",
    "chapterNum": 4
  },
  {
    "question": "마이크로서비스 아키텍처의 장점은?",
    "option1": "한 번에 전체 시스템을 배포할 수 있다",
    "option2": "각 서비스가 독립적으로 배포 및 확장 가능하다",
    "option3": "하나의 DB만 사용 가능하다",
    "option4": "코드 재사용이 불가능하다",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Redis는 어떤 용도로 주로 사용되는가?",
    "option1": "정적 파일 전송",
    "option2": "UI 컴포넌트 렌더링",
    "option3": "메모리 기반 캐시 및 세션 저장",
    "option4": "SSL 인증 처리",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "RabbitMQ와 Kafka는 어떤 시스템에 속하는가?",
    "option1": "파일 처리 라이브러리",
    "option2": "이벤트 기반 메시징 큐 시스템",
    "option3": "암호화 엔진",
    "option4": "웹 서버 프레임워크",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "AWS S3는 어떤 목적에 사용되는 서비스인가?",
    "option1": "웹 서버 관리",
    "option2": "정적 파일 저장 및 전송",
    "option3": "API Gateway 역할 수행",
    "option4": "DB 트랜잭션 처리",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "OAuth2의 Authorization Code Flow는 주로 어떤 앱에 사용되는가?",
    "option1": "클라이언트 시크릿을 보호할 수 없는 앱",
    "option2": "서버-클라이언트 구조에서 높은 보안이 필요한 앱",
    "option3": "토큰 없는 오프라인 앱",
    "option4": "데스크탑용 게임",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Helmet 미들웨어의 주요 목적은?",
    "option1": "라우팅을 간결하게 만든다",
    "option2": "응답 헤더를 조작해 보안을 강화한다",
    "option3": "에러 메시지를 JSON으로 출력한다",
    "option4": "서버에 로그를 저장한다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Node.js에서 다중 프로세스를 통해 성능을 높일 수 있는 모드는?",
    "option1": "Standalone Mode",
    "option2": "Parallel Mode",
    "option3": "Cluster Mode",
    "option4": "Linear Mode",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 유닛 테스트 프레임워크로 알맞은 것은?",
    "option1": "Postman",
    "option2": "Jest",
    "option3": "Docker",
    "option4": "Redis",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "GitHub Actions의 주요 역할은?",
    "option1": "코드 에디터 기능 제공",
    "option2": "리포지토리 삭제",
    "option3": "CI/CD 자동화 파이프라인 구성",
    "option4": "브라우저 렌더링 최적화",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "GraphQL의 장점 중 하나는?",
    "option1": "REST보다 항상 빠르다",
    "option2": "요청자가 필요한 데이터만 선택적으로 요청할 수 있다",
    "option3": "서버에서 URI를 자동 생성한다",
    "option4": "NoSQL 전용으로만 사용할 수 있다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "아키텍처 설계, 확장성 및 배포 전략",
    "chapterNum": 5
  }



]
