[
  {
    "question": "Django 모델 클래스는 어떤 클래스를 상속받아야 하는가?",
    "option1": "BaseView",
    "option2": "models.Base",
    "option3": "models.Model",
    "option4": "django.db.Model",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Django 모델에서 기본 키(primary key)를 자동으로 설정해주는 필드는?",
    "option1": "models.PrimaryField",
    "option2": "models.CharField(primary=True)",
    "option3": "models.AutoField(primary_key=True)",
    "option4": "models.IDField",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "모델 인스턴스를 저장하려면 어떤 메서드를 호출해야 하는가?",
    "option1": "commit()",
    "option2": "persist()",
    "option3": "save()",
    "option4": "apply()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "모든 객체를 가져오는 기본 쿼리셋 메서드는?",
    "option1": "Model.get_all()",
    "option2": "Model.fetch()",
    "option3": "Model.objects.get()",
    "option4": "Model.objects.all()",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "Django 모델에서 ForeignKey 필드를 정의할 때 필요한 인자는?",
    "option1": "related_name",
    "option2": "to",
    "option3": "on_delete",
    "option4": "unique",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "Django의 Meta 클래스에서 db_table 옵션의 역할은?",
    "option1": "테이블 컬럼 이름 지정",
    "option2": "모델의 필드 순서를 지정",
    "option3": "DB에 저장될 테이블 이름 지정",
    "option4": "모델 마이그레이션 방지",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "모델에서 __str__ 메서드를 재정의하는 이유는?",
    "option1": "객체의 ID를 바꾸기 위해",
    "option2": "객체를 JSON으로 직렬화하기 위해",
    "option3": "객체를 프린트할 때 의미 있는 문자열 반환",
    "option4": "쿼리 최적화를 위해",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "다음 중 null=True가 의미하는 것은?",
    "option1": "필드를 인덱싱한다",
    "option2": "필드를 DB에서 무시한다",
    "option3": "DB에 NULL 값을 허용한다",
    "option4": "입력값을 항상 저장한다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "unique=True 옵션은 어떤 제약 조건을 부여하는가?",
    "option1": "필수 입력 필드로 설정",
    "option2": "다른 테이블과 관계 설정",
    "option3": "같은 값을 가진 행이 DB에 존재할 수 없음",
    "option4": "입력 시 자동으로 생성",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  {
    "question": "쿼리셋에 조건을 적용하려면 어떤 메서드를 사용하는가?",
    "option1": "filter()",
    "option2": "annotate()",
    "option3": "exclude()",
    "option4": "aggregate()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Django ORM과 모델 유틸",
    "chapterNum": 1
  },
  
  {
    "question": "Django에서 기본 제공하는 인증 시스템은 어떤 앱에 포함되어 있는가?",
    "option1": "django.contrib.auth",
    "option2": "django.core.auth",
    "option3": "django.auth.system",
    "option4": "django.user.manager",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "DRF에서 인증되지 않은 사용자가 접근할 경우 반환되는 기본 응답 코드는?",
    "option1": "200 OK",
    "option2": "403 Forbidden",
    "option3": "401 Unauthorized",
    "option4": "400 Bad Request",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "Simple JWT에서 토큰을 발급받기 위해 사용하는 기본 엔드포인트는?",
    "option1": "/auth/jwt/",
    "option2": "/api/token/",
    "option3": "/user/login/",
    "option4": "/jwt/token/get/",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "DRF 시리얼라이저에서 유효성 검사를 수동으로 수행하는 메서드는?",
    "option1": "check_valid()",
    "option2": "validate()",
    "option3": "run_validation()",
    "option4": "is_valid()",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "시리얼라이저 필드에서 'read_only=True'로 설정하면?",
    "option1": "필드를 DB에 저장하지 않음",
    "option2": "해당 필드는 응답에만 포함되고 요청에서 무시됨",
    "option3": "필드를 무조건 필수 입력으로 설정함",
    "option4": "HTML 렌더링 전용",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "시리얼라이저 필드에 custom validator를 적용하려면 어떤 매개변수를 사용하는가?",
    "option1": "clean",
    "option2": "validate_with",
    "option3": "validators",
    "option4": "check_field",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "DRF에서 사용자의 권한을 제어하는 클래스 기반 기능은?",
    "option1": "ViewSet",
    "option2": "Permission",
    "option3": "Throttle",
    "option4": "FieldLevelSecurity",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "Simple JWT에서 access token과 refresh token의 차이는?",
    "option1": "access는 더 긴 만료시간을 가진다",
    "option2": "refresh는 로그인 로그를 포함한다",
    "option3": "access는 API 호출에 직접 사용되고 refresh는 재발급용",
    "option4": "둘 다 동일하게 사용된다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "DRF의 BasePermission 클래스를 상속하여 사용할 경우 반드시 구현해야 할 메서드는?",
    "option1": "check_user()",
    "option2": "has_permission()",
    "option3": "is_valid()",
    "option4": "grant_access()",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },
  {
    "question": "시리얼라이저에서 전체 객체 단위로 유효성을 검사할 때 사용하는 메서드는?",
    "option1": "validate_<field>()",
    "option2": "check_valid()",
    "option3": "validate()",
    "option4": "full_clean()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인증, 권한, 시리얼라이저 검증",
    "chapterNum": 2
  },

  {
    "question": "Django REST Framework에서 CRUD 작업을 모두 처리하는 기본 클래스는?",
    "option1": "APIView",
    "option2": "ViewSet",
    "option3": "ListView",
    "option4": "FormView",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "DRF에서 자동으로 URL 라우팅을 도와주는 도구는?",
    "option1": "PathResolver",
    "option2": "UrlPatternBuilder",
    "option3": "Router",
    "option4": "LinkBinder",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "DRF의 ModelSerializer는 어떤 기능을 제공하는가?",
    "option1": "Form validation만 수행",
    "option2": "뷰 없이 HTML을 렌더링",
    "option3": "모델 필드를 자동으로 시리얼라이징",
    "option4": "자바스크립트 기반 REST API 구성",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "ListAPIView는 어떤 기능을 담당하는가?",
    "option1": "POST 요청 처리",
    "option2": "DELETE 요청 처리",
    "option3": "리스트 조회(GET)만 담당",
    "option4": "HTML Form 처리",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "APIView와 GenericAPIView의 주요 차이점은?",
    "option1": "APIView는 기능이 더 많다",
    "option2": "GenericAPIView는 믹스인을 통해 공통 기능을 제공",
    "option3": "APIView는 HTML 응답만 지원한다",
    "option4": "GenericAPIView는 장고 폼에 특화되어 있다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "DRF에서 객체를 데이터로 직렬화하는 기본 단위는?",
    "option1": "View",
    "option2": "Model",
    "option3": "Serializer",
    "option4": "Router",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "다음 중 RetrieveAPIView가 처리하는 요청은?",
    "option1": "객체 삭제",
    "option2": "객체 단건 조회",
    "option3": "객체 리스트 조회",
    "option4": "객체 생성",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "ViewSet을 사용하면 어떤 점이 유리한가?",
    "option1": "모델 정의 없이 API 구성 가능",
    "option2": "직렬화 없이 HTML 반환",
    "option3": "CRUD API를 하나의 클래스에서 관리 가능",
    "option4": "로그인 페이지를 자동 생성",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "Serializer 클래스에서 create() 메서드의 목적은?",
    "option1": "객체를 삭제한다",
    "option2": "새 객체를 생성하여 저장한다",
    "option3": "뷰를 렌더링한다",
    "option4": "폼을 유효성 검사한다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },
  {
    "question": "DRF에서 @action 데코레이터는 무엇을 위한 기능인가?",
    "option1": "쿼리 최적화",
    "option2": "Serializer 확장",
    "option3": "커스텀 라우팅 기능 추가",
    "option4": "폼 자동 생성",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Django REST Framework 및 API 구축",
    "chapterNum": 3
  },

  {
    "question": "Django에서 기본적으로 제공하는 캐시 백엔드는?",
    "option1": "Memcached",
    "option2": "Redis",
    "option3": "LocMemCache",
    "option4": "FileCache",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Celery의 주요 목적은?",
    "option1": "정적 파일 서빙",
    "option2": "비동기 작업 처리",
    "option3": "템플릿 렌더링",
    "option4": "DB 마이그레이션",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Celery와 함께 주기적인 작업을 등록할 때 사용하는 패키지는?",
    "option1": "celery-scheduler",
    "option2": "django-beat",
    "option3": "django-celery-beat",
    "option4": "crontab-plus",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Redis를 Django 캐시로 사용할 때 필요한 설정 항목은?",
    "option1": "CACHES['BACKEND'] = 'django.core.cache.backends.redis.RedisCache'",
    "option2": "CACHES['ENGINE'] = 'django.cache.redis'",
    "option3": "USE_REDIS = True",
    "option4": "REDIS_MODE = 'cache'",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Django 로깅 설정에서 로그 파일 저장을 위해 설정해야 할 핸들러는?",
    "option1": "console",
    "option2": "file",
    "option3": "email",
    "option4": "stream",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "로깅 레벨 중 가장 낮은 단계는?",
    "option1": "WARNING",
    "option2": "INFO",
    "option3": "DEBUG",
    "option4": "ERROR",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Celery에서 task 함수로 등록하려면 어떤 데코레이터를 사용하는가?",
    "option1": "@background",
    "option2": "@task",
    "option3": "@celery_task",
    "option4": "@shared_task",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Sentry의 주요 역할은?",
    "option1": "DB 최적화",
    "option2": "정적 파일 관리",
    "option3": "서버 예외 추적 및 오류 모니터링",
    "option4": "URL 라우팅",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Django에서 캐시 만료 시간을 설정하려면 어떤 속성을 사용해야 하는가?",
    "option1": "cache_age",
    "option2": "max_age",
    "option3": "timeout",
    "option4": "expires_in",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "Celery worker를 실행하는 기본 명령어는?",
    "option1": "celery --run",
    "option2": "celery -A project_name run",
    "option3": "celery -A project_name worker",
    "option4": "celery worker start",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "캐시, 비동기 작업, 로깅 처리",
    "chapterNum": 4
  },
  {
    "question": "pytest-django의 주요 기능은?",
    "option1": "템플릿 렌더링 속도 향상",
    "option2": "Django 프로젝트에서 pytest 기반 테스트 지원",
    "option3": "API 자동 문서 생성",
    "option4": "뷰 캐싱 처리",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "drf-yasg 라이브러리는 어떤 목적으로 사용되는가?",
    "option1": "배포 자동화",
    "option2": "JWT 토큰 발급",
    "option3": "Swagger 기반 API 문서 자동 생성",
    "option4": "URL 리다이렉션 처리",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "Gunicorn은 어떤 역할을 하는가?",
    "option1": "정적 파일을 제공",
    "option2": "WAS 역할의 Python WSGI HTTP 서버",
    "option3": "백엔드 인증 서버",
    "option4": "웹소켓 처리 서버",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "Dockerfile에서 Django 앱을 실행하는 명령은?",
    "option1": "python start",
    "option2": "python manage.py serve",
    "option3": "python manage.py runserver 0.0.0.0:8000",
    "option4": "python django start",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "pytest에서 테스트 파일 이름의 접두사는 일반적으로?",
    "option1": "test_",
    "option2": "check_",
    "option3": "spec_",
    "option4": "case_",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "Django의 `collectstatic` 명령어는 어떤 기능을 수행하는가?",
    "option1": "API 문서를 생성",
    "option2": "시리얼라이저를 캐싱",
    "option3": "정적 파일을 하나의 디렉토리로 모음",
    "option4": "마이그레이션을 실행",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "drf-yasg에서 API 문서를 Swagger UI 형식으로 보려면 어떤 URL을 사용하는가?",
    "option1": "/docs/",
    "option2": "/openapi/",
    "option3": "/swagger/",
    "option4": "/schema/swagger/",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "Docker를 활용해 Django를 배포할 때 보통 함께 사용하는 WSGI 서버는?",
    "option1": "uWSGI 또는 Gunicorn",
    "option2": "Apache",
    "option3": "NGROK",
    "option4": "FlaskServe",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "Nginx가 Django 앱 앞에 위치하는 일반적인 역할은?",
    "option1": "ORM 처리",
    "option2": "REST API 정의",
    "option3": "정적 파일 제공 및 리버스 프록시",
    "option4": "템플릿 렌더링",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  },
  {
    "question": "pytest에서 Django 설정을 적용하려면 어떤 플러그인이 필요한가?",
    "option1": "pytest-setup",
    "option2": "pytest-config",
    "option3": "pytest-django",
    "option4": "pytest-env",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 문서화 및 배포 도구 활용",
    "chapterNum": 5
  }




]
