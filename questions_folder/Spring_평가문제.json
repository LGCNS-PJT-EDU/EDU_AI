[
  {
    "question": "Java에서 클래스가 객체로 생성되기 위해 사용하는 키워드는?",
    "option1": "define",
    "option2": "instanceof",
    "option3": "new",
    "option4": "object",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 IoC(제어의 역전)가 의미하는 것은?",
    "option1": "개발자가 직접 객체를 관리",
    "option2": "사용자 요청을 직접 제어",
    "option3": "객체의 제어를 컨테이너가 담당",
    "option4": "데이터를 하드코딩으로 처리",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Spring에서 의존성 주입(DI)을 구현할 수 있는 방법이 아닌 것은?",
    "option1": "생성자 주입",
    "option2": "세터 주입",
    "option3": "필드 주입",
    "option4": "상속 주입",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Java의 접근 제어자 중 같은 클래스에서만 접근 가능한 것은?",
    "option1": "private",
    "option2": "protected",
    "option3": "public",
    "option4": "default",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "@SpringBootApplication 어노테이션은 무엇을 포함하는가?",
    "option1": "@Entity, @Bean",
    "option2": "@Configuration, @EnableAutoConfiguration, @ComponentScan",
    "option3": "@RestController, @Autowired",
    "option4": "@Service, @Repository",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Java에서 오버라이딩(Overriding)은 어떤 경우 사용하는가?",
    "option1": "같은 클래스에서 같은 이름의 메서드 정의",
    "option2": "부모 클래스의 메서드를 자식 클래스에서 재정의",
    "option3": "같은 클래스에서 메서드명을 바꿔 재정의",
    "option4": "static 메서드를 변경",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 Bean을 생성하고 관리하는 핵심 컨테이너는?",
    "option1": "HttpSession",
    "option2": "ServletContext",
    "option3": "ApplicationContext",
    "option4": "WebSocketContext",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Java에서 null을 반환할 수 있는 메서드를 대체하기 위한 클래스는?",
    "option1": "Void",
    "option2": "Nullable",
    "option3": "Optional",
    "option4": "Maybe",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "Spring에서 Bean의 라이프사이클 중 객체가 생성된 후 초기화를 위한 메서드는?",
    "option1": "@PostConstruct",
    "option2": "@InitBinder",
    "option3": "@Autowired",
    "option4": "@PreDestroy",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Java의 예외(Exception) 처리 방식으로 올바른 것은?",
    "option1": "try-catch-finally",
    "option2": "assert-try-catch",
    "option3": "if-throw-catch",
    "option4": "try-return",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Java & Spring 기초 개념 이해",
    "chapterNum": 1
  },

  {
    "question": "3계층 아키텍처에서 Controller의 주요 역할은?",
    "option1": "비즈니스 로직을 처리",
    "option2": "데이터베이스 쿼리를 직접 실행",
    "option3": "사용자의 요청을 받아 Service에 전달",
    "option4": "Entity를 직접 리턴",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "Service 계층의 주요 책임은?",
    "option1": "HTML 응답을 구성한다",
    "option2": "데이터를 화면에 표시한다",
    "option3": "비즈니스 로직을 수행한다",
    "option4": "파일 시스템과 통신한다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "DTO의 주요 목적은?",
    "option1": "JPA 쿼리 최적화",
    "option2": "계층 간 필요한 데이터만 전달",
    "option3": "데이터베이스 매핑",
    "option4": "보안 설정 구성",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "Entity와 VO(Value Object)의 주요 차이는?",
    "option1": "Entity는 값을 비교하고, VO는 참조를 비교한다",
    "option2": "VO는 식별자가 있고, Entity는 없다",
    "option3": "Entity는 식별자를 가지며 VO는 값 자체로 동등성 판단",
    "option4": "VO는 DB에 저장되며 Entity는 캐시에 저장된다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "Repository의 책임으로 올바른 것은?",
    "option1": "데이터 접근 및 조작",
    "option2": "사용자 요청 처리",
    "option3": "에러 로그 기록",
    "option4": "API 응답 캐싱",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "Spring의 의존성 주입(DI)을 통해 얻을 수 있는 효과는?",
    "option1": "코드 실행 속도 향상",
    "option2": "컴파일 타임 단축",
    "option3": "결합도 감소 및 테스트 용이성 향상",
    "option4": "JVM 메모리 최적화",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "다음 중 계층 구조를 따르지 않을 때 발생할 수 있는 문제는?",
    "option1": "보안 강화",
    "option2": "단일 책임 원칙 위반",
    "option3": "응답 속도 향상",
    "option4": "캐시 히트율 증가",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "다음 중 VO(Value Object)의 특성으로 적절한 것은?",
    "option1": "식별자를 기반으로 관리",
    "option2": "불변 객체로 사용",
    "option3": "JPA Repository로 관리",
    "option4": "비즈니스 로직 수행",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "DTO를 Entity로 변환하는 방법으로 가장 적절한 것은?",
    "option1": "컨트롤러에서 직접 Entity 생성",
    "option2": "Service 계층에서 변환 로직 구현",
    "option3": "Repository에서 자동 변환",
    "option4": "HTML 템플릿에서 처리",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "계층 구조 설계의 가장 큰 장점 중 하나는?",
    "option1": "코드 길이 단축",
    "option2": "정렬 속도 향상",
    "option3": "유지보수성과 테스트 용이성",
    "option4": "화면 렌더링 속도 향상",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "계층 구조 및 실무 설계 패턴",
    "chapterNum": 2
  },
  {
    "question": "@Entity 어노테이션은 어떤 클래스를 대상으로 사용되는가?",
    "option1": "컨트롤러 클래스",
    "option2": "데이터베이스 테이블과 매핑되는 클래스",
    "option3": "DTO 클래스",
    "option4": "뷰(View) 클래스",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "JPA에서 기본 키 생성을 위한 어노테이션은?",
    "option1": "@Primary",
    "option2": "@Generated",
    "option3": "@Id",
    "option4": "@GeneratedValue",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "Spring Data JPA에서 findById() 메서드가 반환하는 타입은?",
    "option1": "Entity",
    "option2": "Optional<Entity>",
    "option3": "List<Entity>",
    "option4": "void",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "JPA의 영속성 컨텍스트(Persistence Context)의 주요 역할은?",
    "option1": "트랜잭션을 종료한다",
    "option2": "DB 커넥션을 유지한다",
    "option3": "엔티티 객체를 1차 캐시에 저장하고 관리한다",
    "option4": "SQL 쿼리를 자동 분석한다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "Spring에서 @Transactional을 사용하는 이유는?",
    "option1": "HTTP 요청 처리를 위해",
    "option2": "서버 부하 분산",
    "option3": "트랜잭션 단위로 작업을 처리하기 위해",
    "option4": "Entity를 자동 생성하기 위해",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "@Query 어노테이션은 언제 사용하는가?",
    "option1": "DTO를 생성할 때",
    "option2": "기본 메서드로 처리 불가능한 쿼리를 직접 작성할 때",
    "option3": "API 요청을 받을 때",
    "option4": "Entity 클래스를 정의할 때",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "JPA에서 연관 관계를 정의할 때 사용하는 어노테이션은?",
    "option1": "@Relationship",
    "option2": "@RelationMapping",
    "option3": "@OneToMany / @ManyToOne",
    "option4": "@EntityJoin",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "트랜잭션의 전파 속성 중 Propagation.REQUIRES_NEW의 의미는?",
    "option1": "기존 트랜잭션이 있으면 참여",
    "option2": "기존 트랜잭션이 있으면 종료하고 새 트랜잭션 시작",
    "option3": "항상 기존 트랜잭션에 참여",
    "option4": "트랜잭션을 비활성화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "JPA에서 Lazy Loading의 특징은?",
    "option1": "즉시 모든 연관 데이터를 로딩",
    "option2": "쿼리 실행 시 연관 객체를 모두 미리 로딩",
    "option3": "필요할 때 연관 객체를 조회",
    "option4": "데이터를 캐시에 저장하지 않음",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "트랜잭션 격리 수준 중 가장 높은 단계는?",
    "option1": "READ UNCOMMITTED",
    "option2": "READ COMMITTED",
    "option3": "REPEATABLE READ",
    "option4": "SERIALIZABLE",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "Spring Data JPA & 트랜잭션",
    "chapterNum": 3
  },
  {
    "question": "Spring Security의 가장 핵심 기능은 무엇인가?",
    "option1": "데이터베이스 관리",
    "option2": "API 속도 최적화",
    "option3": "웹 애플리케이션의 인증과 인가 처리",
    "option4": "HTML 템플릿 렌더링",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Spring Security에서 인증(Authentication)은 무엇을 의미하는가?",
    "option1": "요청 데이터를 검증하는 과정",
    "option2": "사용자의 신원을 확인하는 과정",
    "option3": "비밀번호 암호화 처리",
    "option4": "로그 기록 저장",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "@PreAuthorize 어노테이션은 어떤 용도로 사용되는가?",
    "option1": "API 문서 생성을 위해",
    "option2": "데이터베이스 연결 설정",
    "option3": "메서드 실행 전에 권한 검사 수행",
    "option4": "클래스 로딩을 지연시킴",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "JWT에서 Access Token이 하는 역할은?",
    "option1": "비밀번호 저장",
    "option2": "사용자의 인증 정보를 포함한 토큰으로 요청 시 사용",
    "option3": "쿠키를 암호화하는 방식",
    "option4": "DB 세션 관리를 위한 키",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Spring Security에서 필터 기반 인증 구조의 시작점은?",
    "option1": "UserDetailsService",
    "option2": "SecurityConfig",
    "option3": "UsernamePasswordAuthenticationFilter",
    "option4": "PasswordEncoder",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Swagger의 주요 기능은?",
    "option1": "보안 토큰 암호화",
    "option2": "API 명세서 자동 생성 및 테스트 지원",
    "option3": "JPA 쿼리 자동 생성",
    "option4": "Java 코드 컴파일",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Swagger UI의 기본 접근 경로는?",
    "option1": "/swagger-ui",
    "option2": "/docs",
    "option3": "/swagger-ui.html",
    "option4": "/api/swagger",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Spring Security에서 UserDetailsService는 어떤 역할을 하는가?",
    "option1": "토큰 유효성 검사",
    "option2": "비밀번호 암호화 설정",
    "option3": "사용자 인증 정보를 DB에서 로드",
    "option4": "API 응답 형식 지정",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Swagger 문서에서 메서드 설명을 추가할 때 사용하는 어노테이션은?",
    "option1": "@ApiParam",
    "option2": "@ApiOperation",
    "option3": "@DocField",
    "option4": "@ApiInfo",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "JWT 기반 인증 시스템의 장점으로 옳은 것은?",
    "option1": "세션 유지 없이 상태 기반 인증 구현 가능",
    "option2": "서버에 세션 저장 공간이 필요하다",
    "option3": "매 요청마다 DB 조회가 필수다",
    "option4": "CSRF 보호가 기본 내장되어 있다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "인증, 보안 및 문서화 도구 활용",
    "chapterNum": 4
  },
  {
    "question": "Kotlin Coroutine의 가장 큰 특징은?",
    "option1": "동기적으로 실행된다",
    "option2": "스레드 블로킹 없이 비동기 처리를 가능하게 한다",
    "option3": "JVM에서 실행되지 않는다",
    "option4": "항상 새로운 스레드를 생성한다",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Spring에서 @Async를 사용하면 어떤 효과가 있는가?",
    "option1": "API 문서화",
    "option2": "동기 실행 보장",
    "option3": "비동기 메서드 실행",
    "option4": "Entity 자동 매핑",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "JPA에서 N+1 문제 해결을 위한 방법으로 적절한 것은?",
    "option1": "별도의 쿼리 파일 분리",
    "option2": "DTO로 엔티티 반환",
    "option3": "Fetch Join 사용",
    "option4": "트랜잭션 제거",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 Redis를 사용한 캐싱에서 TTL(Time To Live)의 역할은?",
    "option1": "데이터 업데이트 트리거",
    "option2": "캐시 데이터의 유효 기간 설정",
    "option3": "쿼리 실행 순서 설정",
    "option4": "데이터 정렬 기준 설정",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Spring Security + JWT 기반 인증에서 토큰 발급 객체는?",
    "option1": "AuthenticationEntryPoint",
    "option2": "TokenProvider 또는 JwtUtil",
    "option3": "OAuth2User",
    "option4": "WebSecurityConfigurer",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "OAuth2 로그인 시 리디렉션 URI는 어떤 역할을 하는가?",
    "option1": "사용자 ID 확인",
    "option2": "리소스 서버 요청을 중단",
    "option3": "인가 서버가 인증 후 리다이렉트할 클라이언트 주소",
    "option4": "JWT 발급을 담당",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "JPA Auditing에서 생성 시간을 자동으로 기록하는 어노테이션은?",
    "option1": "@CreatedTime",
    "option2": "@ModifiedDate",
    "option3": "@CreatedDate",
    "option4": "@Timestamp",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "Spring Boot 멀티 모듈 프로젝트의 주요 장점은?",
    "option1": "전체 모듈이 하나의 빌드로만 운영됨",
    "option2": "서로 다른 관심사를 모듈로 분리해 관리 가능",
    "option3": "코드 중복 증가",
    "option4": "디버깅이 어려움",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "CI/CD 구성에서 GitHub Actions의 주된 용도는?",
    "option1": "로그 저장",
    "option2": "서버 모니터링",
    "option3": "자동 빌드 및 테스트, 배포 트리거",
    "option4": "HTML 렌더링",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  },
  {
    "question": "헥사고날 아키텍처의 핵심 아이디어는?",
    "option1": "계층 구조를 제거한다",
    "option2": "도메인과 외부 의존성을 철저히 분리",
    "option3": "엔티티 중심으로만 개발",
    "option4": "DB 종속적인 코드 구성",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "실전 고급 기술 & 배포 전략",
    "chapterNum": 5
  }


]
