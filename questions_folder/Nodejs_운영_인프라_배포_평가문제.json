[
  {
    "question": "Node.js 애플리케이션을 프로세스 중단 없이 운영하기 위한 도구로 적절한 것은?",
    "option1": "Webpack",
    "option2": "Nodemon",
    "option3": "PM2",
    "option4": "Nginx",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "PM2로 Node.js 애플리케이션을 시작하는 명령어는?",
    "option1": "pm2 install app.js",
    "option2": "pm2 start app.js",
    "option3": "pm2 run app.js",
    "option4": "pm2 launch app.js",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Node.js 앱을 Docker로 배포할 때 가장 기본적인 구성 파일은?",
    "option1": "Dockerfile",
    "option2": "docker.env",
    "option3": "pm2.config.js",
    "option4": "deploy.yaml",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Nginx를 통해 Node.js 서버로 요청을 전달하는 기능은?",
    "option1": "Static Routing",
    "option2": "Reverse Proxy",
    "option3": "Load Balancing",
    "option4": "DNS Forwarding",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Node.js에서 환경변수를 `.env` 파일로 관리할 때 사용하는 패키지는?",
    "option1": "dotenv",
    "option2": "env-loader",
    "option3": "config.js",
    "option4": "settings",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "process.env.NODE_ENV 값으로 'production'을 설정하는 이유는?",
    "option1": "개발 환경에서만 동작하게 하기 위해",
    "option2": "프로덕션 전용 설정을 로드하기 위해",
    "option3": "환경 변수를 비활성화하기 위해",
    "option4": "Node.js를 종료시키기 위해",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "GitHub Actions에서 `.yml` 파일 내에서 Docker 이미지를 빌드하려면 어떤 명령이 필요한가?",
    "option1": "docker upload",
    "option2": "docker deploy",
    "option3": "docker build",
    "option4": "docker init",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "CI/CD에서 DockerHub에 이미지를 푸시하는 명령어는?",
    "option1": "docker transfer",
    "option2": "docker upload",
    "option3": "docker push",
    "option4": "docker deploy",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "Node.js에서 로그를 파일로 남기기 위해 가장 많이 쓰는 라이브러리는?",
    "option1": "log4js",
    "option2": "Morgan",
    "option3": "Winston",
    "option4": "Bunyan",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Sentry를 사용하는 주된 목적은?",
    "option1": "성능 개선",
    "option2": "에러 추적 및 알림",
    "option3": "파일 저장",
    "option4": "API 문서화",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "PM2에서 애플리케이션을 재시작하는 명령어는?",
    "option1": "pm2 rerun app",
    "option2": "pm2 restart app",
    "option3": "pm2 reset app",
    "option4": "pm2 relaunch app",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "PM2의 주요 기능이 아닌 것은?",
    "option1": "프로세스 자동 재시작",
    "option2": "로드 밸런싱",
    "option3": "로그 기록",
    "option4": "SQL 쿼리 최적화",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Node.js 앱이 비정상 종료되었을 때 PM2가 자동으로 재시작하도록 하는 설정은?",
    "option1": "pm2 auto-restart",
    "option2": "restart_on_fail",
    "option3": "watch mode",
    "option4": "forever mode",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Docker를 사용할 때 Node.js 컨테이너에 Nginx를 연결하는 이유는?",
    "option1": "DB와 연결하기 위해",
    "option2": "정적 파일을 자동 생성하기 위해",
    "option3": "보안 인증을 위해",
    "option4": "Reverse Proxy 및 로드 밸런싱을 위해",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Dockerfile에서 Node.js 앱의 종속성을 설치하는 명령은?",
    "option1": "RUN node install",
    "option2": "RUN npm install",
    "option3": "RUN install dependencies",
    "option4": "RUN yarn package",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Nginx 설정에서 Node.js 서버로 트래픽을 전달하는 지시어는?",
    "option1": "proxy_pass",
    "option2": "forward_to",
    "option3": "pass_traffic",
    "option4": "connect_node",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": ".env 파일을 Node.js에서 읽어들이기 위한 적절한 순서는?",
    "option1": "require('dotenv').run()",
    "option2": "require('env').load()",
    "option3": "require('dotenv').config()",
    "option4": "import dotenv from 'envfile'",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "환경별 설정을 구분하여 관리하기 위한 방식으로 적절한 것은?",
    "option1": "하나의 .env 파일에 모두 작성",
    "option2": "config.js에서 분기 처리",
    "option3": "패키지.json에 작성",
    "option4": "app.js 상단에 직접 작성",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "CI/CD에서 테스트를 자동으로 실행하는 주요 목적은?",
    "option1": "배포 속도 향상",
    "option2": "보안 강화",
    "option3": "코드 품질 확보",
    "option4": "서버 비용 절감",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "GitHub Actions 워크플로우에서 main 브랜치에 push될 때만 작동하게 하려면 사용하는 키워드는?",
    "option1": "on: push",
    "option2": "on: pull",
    "option3": "on: commit",
    "option4": "on: deploy",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "GitHub Actions의 steps 내에서 쉘 명령어를 실행하려면 어떤 키워드를 사용해야 하나?",
    "option1": "shell",
    "option2": "run",
    "option3": "execute",
    "option4": "command",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "Winston 로깅 라이브러리에서 로그 수준을 설정하는 기본 키워드는?",
    "option1": "level",
    "option2": "severity",
    "option3": "priority",
    "option4": "logType",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Winston의 로그를 파일에 저장하려면 사용하는 transport는?",
    "option1": "ConsoleTransport",
    "option2": "FileTransport",
    "option3": "StreamTransport",
    "option4": "LogTransport",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "로그 파일의 용량이 커질 때 오래된 로그를 자동으로 제거해주는 도구는?",
    "option1": "logrotate",
    "option2": "filewatcher",
    "option3": "winston-pruner",
    "option4": "logclean",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Sentry의 주요 기능은 다음 중 무엇인가?",
    "option1": "로그 색인",
    "option2": "트래픽 분석",
    "option3": "에러 추적",
    "option4": "성능 테스트",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Sentry를 Node.js 프로젝트에 통합하려면 어떤 패키지를 설치해야 하나?",
    "option1": "@sentry/node",
    "option2": "sentry-js",
    "option3": "node-sentry",
    "option4": "sentry-logger",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "PM2에서 JSON 설정 파일을 사용하는 이유는?",
    "option1": "환경변수 암호화",
    "option2": "멀티 서버 연결",
    "option3": "앱 실행 설정을 자동화",
    "option4": "Nginx 연동",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Docker에서 Node.js 앱이 사용하는 포트를 외부에 노출하는 방법은?",
    "option1": "EXPOSE 지시어",
    "option2": "ENV 설정",
    "option3": "CMD 사용",
    "option4": "COPY 포트",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "GitHub Actions에서 secret 값을 안전하게 사용하려면?",
    "option1": "환경 변수로 바로 입력",
    "option2": "yml에 직접 작성",
    "option3": "GitHub Secrets 사용",
    "option4": "config 파일에 저장",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "Node.js에서 운영 환경에서만 에러를 로깅하도록 하려면 조건문에 사용하는 값은?",
    "option1": "process.env.LOG_LEVEL",
    "option2": "process.env.NODE_ENV",
    "option3": "process.env.MODE",
    "option4": "process.env.DEBUG",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "PM2에서 로그를 확인하는 명령어는?",
    "option1": "pm2 show logs",
    "option2": "pm2 read logs",
    "option3": "pm2 logs",
    "option4": "pm2 status logs",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "PM2의 process.json에서 실행할 스크립트를 정의하는 키는?",
    "option1": "entry",
    "option2": "script",
    "option3": "exec",
    "option4": "main",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "PM2 프로세스를 영구적으로 등록해 서버 재부팅 후에도 실행하려면?",
    "option1": "pm2 startup",
    "option2": "pm2 persist",
    "option3": "pm2 monitor",
    "option4": "pm2 keepalive",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Docker에서 Node.js 앱을 개발 모드로 실행하려면 어떤 명령이 유용한가?",
    "option1": "docker build",
    "option2": "docker compose dev",
    "option3": "docker run -v",
    "option4": "docker exec -it",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Nginx에서 정적 파일 서비스를 위한 디렉토리 설정 키워드는?",
    "option1": "static_path",
    "option2": "root",
    "option3": "location",
    "option4": "static_dir",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Dockerfile에서 애플리케이션의 실행 커맨드를 지정하는 지시어는?",
    "option1": "RUN",
    "option2": "START",
    "option3": "CMD",
    "option4": "ENTRY",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "Node.js에서 dotenv 라이브러리를 사용하는 주요 이유는?",
    "option1": "파일 압축",
    "option2": "보안 검사",
    "option3": "환경 변수 로드",
    "option4": "모듈 번들링",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "환경 설정 파일을 Git에 올리지 않기 위해 사용하는 파일은?",
    "option1": "git.config",
    "option2": ".env",
    "option3": ".gitignore",
    "option4": "ignore.env",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "NODE_ENV를 'production'으로 설정하는 이유는?",
    "option1": "앱이 자동으로 중단되기 위해",
    "option2": "운영 환경에 최적화된 동작을 위해",
    "option3": "테스트 스크립트를 실행하기 위해",
    "option4": "개발 서버를 우선 실행하기 위해",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  },
  {
    "question": "CI 파이프라인에서 'build' 단계가 실행되는 시점은?",
    "option1": "코드 작성 후",
    "option2": "테스트 실행 전",
    "option3": "코드가 push될 때",
    "option4": "릴리즈 후",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "GitHub Actions에서 워크플로우 파일의 확장자는?",
    "option1": ".js",
    "option2": ".yml",
    "option3": ".git",
    "option4": ".workflow",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "CI/CD에서 'deploy' 단계의 목적은?",
    "option1": "코드를 병합하는 것",
    "option2": "코드를 배포 환경에 전달하는 것",
    "option3": "코드를 테스트하는 것",
    "option4": "코드를 분석하는 것",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "Winston에서 여러 로그 출력 방식을 정의하는 구성 요소는?",
    "option1": "handler",
    "option2": "exporter",
    "option3": "transport",
    "option4": "logger",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Sentry에서 에러를 수집하기 위해 가장 먼저 해야 할 작업은?",
    "option1": "코드에 에러 발생시키기",
    "option2": "Sentry 계정 만들기",
    "option3": "코드에 DSN 설정",
    "option4": "환경변수 설정",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Sentry는 어떤 종류의 툴인가?",
    "option1": "배포 자동화 툴",
    "option2": "에러 추적 및 로깅 툴",
    "option3": "코드 최적화 툴",
    "option4": "DB 관리 툴",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "Node.js에서 Winston 로그 포맷을 설정할 때 사용하는 객체는?",
    "option1": "format",
    "option2": "template",
    "option3": "style",
    "option4": "layout",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "모니터링 & 로깅 (Winston, Logrotate, Sentry 등)",
    "chapterNum": 5
  },
  {
    "question": "GitHub Actions에서 여러 Job이 순서대로 실행되도록 하려면?",
    "option1": "run-after",
    "option2": "order-by",
    "option3": "needs",
    "option4": "depends",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "CI/CD (GitHub Actions, DockerHub 등)",
    "chapterNum": 4
  },
  {
    "question": "PM2로 실행된 프로세스를 중단하려면 어떤 명령어를 사용할까?",
    "option1": "pm2 remove",
    "option2": "pm2 pause",
    "option3": "pm2 stop",
    "option4": "pm2 down",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Node.js 프로세스 관리 (PM2 등)",
    "chapterNum": 1
  },
  {
    "question": "Docker 이미지 빌드 시 캐시를 사용하지 않으려면 어떤 옵션을 사용하나?",
    "option1": "--no-cache",
    "option2": "--force",
    "option3": "--no-save",
    "option4": "--clear",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Node.js 배포 (Docker, Nginx, Reverse Proxy)",
    "chapterNum": 2
  },
  {
    "question": "환경에 따라 설정 파일을 다르게 로드할 때 흔히 사용하는 node 패턴은?",
    "option1": "switch(process.env.MODE)",
    "option2": "if (config.env === 'prod')",
    "option3": "require('./config')[process.env.NODE_ENV]",
    "option4": "config.use(process.env.SETTING)",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "환경 변수 및 설정 관리 (.env, config 등)",
    "chapterNum": 3
  }
]