[
  {
    "question": "Spring Data JPA에서 Repository 인터페이스를 만들기만 해도 쿼리가 작동하는 이유는?",
    "option1": "자동 컴파일 기능 덕분",
    "option2": "Spring이 내부적으로 SQL을 생성해주기 때문",
    "option3": "JVM이 데이터를 추론하기 때문",
    "option4": "Hibernate가 모든 쿼리를 캐싱하기 때문",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "JPA에서 @Entity가 붙은 클래스의 의미는?",
    "option1": "클래스를 HTTP 요청으로 사용한다는 뜻",
    "option2": "클래스를 DB 테이블과 매핑하겠다는 뜻",
    "option3": "클래스를 DTO로 사용하겠다는 뜻",
    "option4": "클래스를 static으로 만든다는 뜻",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "Hibernate에서 '영속성 컨텍스트'의 주요 기능은?",
    "option1": "SQL 정렬 기능",
    "option2": "객체의 생명 주기를 관리하고 1차 캐시 제공",
    "option3": "웹 요청을 모니터링",
    "option4": "클래스 파일을 컴파일",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "QueryDSL의 가장 큰 장점은?",
    "option1": "SQL이 필요 없다",
    "option2": "복잡한 쿼리를 자바 코드로 타입 안정성 있게 작성할 수 있다",
    "option3": "자동으로 API를 생성해준다",
    "option4": "로그를 출력하지 않는다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "다음 중 MyBatis의 주요 특징은?",
    "option1": "ORM 없이 SQL을 XML 또는 Annotation으로 직접 작성",
    "option2": "JPA 기반 쿼리 추상화",
    "option3": "데이터 직렬화 전용 도구",
    "option4": "로그 분석 프레임워크",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "Spring Data JPA에서 사용하는 @Query 어노테이션은 어떤 용도인가?",
    "option1": "객체 직렬화",
    "option2": "직접 JPQL 또는 SQL 쿼리를 작성하기 위해",
    "option3": "엔티티 필터링을 위한 어노테이션",
    "option4": "JSON 변환 설정",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "JPA의 Entity는 기본적으로 어떤 구조로 데이터를 관리하는가?",
    "option1": "스키마리스 구조",
    "option2": "객체지향 매핑 구조",
    "option3": "이벤트 기반 구조",
    "option4": "키-값 저장 구조",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "QueryDSL을 사용하려면 어떤 도구로 Q클래스를 생성해야 하는가?",
    "option1": "IntelliJ",
    "option2": "Gradle Annotation Processor",
    "option3": "Lombok",
    "option4": "JVM",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "MyBatis의 resultMap은 어떤 역할을 수행하는가?",
    "option1": "로그 출력",
    "option2": "쿼리 자동 생성",
    "option3": "SQL 결과를 Java 객체에 매핑",
    "option4": "의존성 주입",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "JPA에서 fetch join을 사용할 때 주의할 점은?",
    "option1": "로그 레벨을 바꿔야 한다",
    "option2": "사용하면 항상 지연 로딩이 된다",
    "option3": "distinct 없이 join이 중복 결과를 만들 수 있다",
    "option4": "쿼리가 캐시되지 않는다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "ORM과 쿼리 매핑 도구",
    "chapterNum": 1
  },
  {
    "question": "Spring Security의 기본 역할은 무엇인가?",
    "option1": "데이터베이스 연결 관리",
    "option2": "HTML 렌더링 최적화",
    "option3": "웹 애플리케이션의 인증 및 인가 처리",
    "option4": "프론트엔드 스타일링",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "JWT에서 토큰의 유효성을 검증하기 위해 필요한 요소는?",
    "option1": "이메일",
    "option2": "DB 연결 정보",
    "option3": "서명에 사용된 시크릿 키",
    "option4": "프론트엔드 라우터",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "다음 중 javax.validation에서 사용되는 어노테이션은?",
    "option1": "@ValidValue",
    "option2": "@Check",
    "option3": "@NotNull",
    "option4": "@EntityCheck",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "@PreAuthorize 어노테이션의 주요 기능은?",
    "option1": "API 호출 로깅",
    "option2": "요청 바디 유효성 검사",
    "option3": "메서드 실행 전에 권한 조건을 평가",
    "option4": "프론트엔드 라우팅을 정의",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "Spring Security에서 Authentication 객체는 어떤 정보를 담고 있는가?",
    "option1": "DB 연결 설정",
    "option2": "인증된 사용자 정보 및 권한",
    "option3": "View 템플릿 이름",
    "option4": "API 문서 경로",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "Validator를 커스터마이징하려면 구현해야 하는 인터페이스는?",
    "option1": "ValidationEngine",
    "option2": "javax.validation.Validator",
    "option3": "SpringSecurityChecker",
    "option4": "ConstraintValidator",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "JWT 토큰 기반 인증의 가장 큰 장점은?",
    "option1": "모든 요청에 대해 DB를 통해 세션 조회",
    "option2": "상태를 서버에 저장하지 않아 확장성이 높음",
    "option3": "서버 부하가 항상 일정함",
    "option4": "응답 시간이 느림",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "Spring Security에서 필터 체인의 순서를 조정하려면 어디에 설정해야 하는가?",
    "option1": "application.yml",
    "option2": "securityFilterChain Bean 등록 시",
    "option3": "Controller 클래스 내부",
    "option4": "Validator 클래스 내부",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "JSR-380은 어떤 기술과 관련 있는 명세인가?",
    "option1": "자바스크립트 비동기 처리",
    "option2": "Java의 Bean Validation (예: @NotNull 등)",
    "option3": "스프링 REST 템플릿",
    "option4": "Gradle 빌드 최적화",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "Spring Security의 인증 실패 처리를 위한 기본 전략은?",
    "option1": "AccessDeniedHandler",
    "option2": "AuthenticationSuccessHandler",
    "option3": "AuthenticationFailureHandler",
    "option4": "UnauthorizedException",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "인증, 검증 및 시큐리티 유틸",
    "chapterNum": 2
  },
  {
    "question": "Swagger의 주된 목적은 무엇인가?",
    "option1": "보안 설정",
    "option2": "API 요청을 암호화",
    "option3": "API 명세서를 자동으로 생성하고 테스트 제공",
    "option4": "로그를 파일에 저장",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "Spring에서 Swagger UI 기본 접근 경로는?",
    "option1": "/docs",
    "option2": "/swagger-ui.html",
    "option3": "/api-spec",
    "option4": "/open-api",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "Springdoc(OpenAPI)에서 자동 문서를 생성하기 위해 사용하는 주석은?",
    "option1": "@ApiDoc",
    "option2": "@RestSchema",
    "option3": "@Operation",
    "option4": "@Describe",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "다음 중 Java 객체를 JSON으로 직렬화할 때 사용하는 Jackson 어노테이션은?",
    "option1": "@JsonSerialize",
    "option2": "@JsonEntity",
    "option3": "@JsonJoin",
    "option4": "@JsonConvert",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "직렬화란 무엇을 의미하는가?",
    "option1": "SQL 쿼리를 정렬",
    "option2": "데이터를 JSON이나 XML 같은 형식으로 변환",
    "option3": "객체를 메모리에 적재",
    "option4": "코드를 자동 컴파일",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "GSON 라이브러리의 주된 기능은?",
    "option1": "REST API 보안",
    "option2": "JSON 직렬화 및 역직렬화",
    "option3": "서버 간 메시지 전달",
    "option4": "스프링 컨텍스트 초기화",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "Swagger에서 각 API의 설명을 작성할 때 사용하는 어노테이션은?",
    "option1": "@ApiDescription",
    "option2": "@ApiInfo",
    "option3": "@ApiOperation",
    "option4": "@OpenApiSpec",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "Jackson에서 특정 필드를 JSON 결과에 포함하지 않으려면 사용하는 어노테이션은?",
    "option1": "@JsonIgnore",
    "option2": "@JsonExclude",
    "option3": "@SkipField",
    "option4": "@HideFromJson",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "Spring REST Docs의 특징으로 올바른 것은?",
    "option1": "테스트 코드 기반으로 문서를 생성",
    "option2": "Swagger UI를 기반으로 한다",
    "option3": "MySQL 데이터 문서를 만든다",
    "option4": "GraphQL 쿼리를 시각화한다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "API 문서화를 위한 Swagger 설정은 보통 어디에 정의하는가?",
    "option1": "DTO 클래스",
    "option2": "application.yml",
    "option3": "SwaggerConfig 클래스",
    "option4": "Controller 내부",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "API 문서화 & 직렬화 도구",
    "chapterNum": 3
  },
  {
    "question": "SLF4J는 어떤 역할을 하는 라이브러리인가?",
    "option1": "API 문서를 생성한다",
    "option2": "SQL 쿼리를 최적화한다",
    "option3": "로깅의 추상화를 제공하여 구현체 교체를 유연하게 한다",
    "option4": "데이터베이스를 백업한다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Logback에 대한 설명으로 올바른 것은?",
    "option1": "HTML 렌더링을 수행한다",
    "option2": "SLF4J를 대체하는 웹 프레임워크이다",
    "option3": "SLF4J의 구현체 중 하나로 로그를 파일, 콘솔 등으로 출력",
    "option4": "보안 필터링 도구이다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring Cache를 사용하기 위해 메서드 위에 붙이는 어노테이션은?",
    "option1": "@CachePut",
    "option2": "@CacheValue",
    "option3": "@Cacheable",
    "option4": "@EnableCache",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Redis의 가장 큰 장점 중 하나는?",
    "option1": "데이터를 장기 보존할 수 있음",
    "option2": "HTTP 요청을 처리함",
    "option3": "메모리 기반 캐싱으로 빠른 데이터 접근 가능",
    "option4": "파일 시스템과 연동이 뛰어남",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring Batch에서 'Job'이란 무엇을 의미하는가?",
    "option1": "하나의 API 요청",
    "option2": "하나의 트랜잭션 처리",
    "option3": "여러 Step으로 구성된 일괄 처리 단위",
    "option4": "하나의 SQL 쿼리",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring Batch의 구성 요소 중 Step의 역할은?",
    "option1": "단위 테스트 실행",
    "option2": "하나의 작업 단계를 의미하며 Reader, Processor, Writer로 구성",
    "option3": "배포 설정을 관리",
    "option4": "에러를 처리",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Spring Batch에서 데이터를 읽는 역할을 수행하는 구성요소는?",
    "option1": "Job",
    "option2": "ItemReader",
    "option3": "ItemWriter",
    "option4": "Tasklet",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring에서 로그를 JSON 포맷으로 출력하려면 사용하는 설정은?",
    "option1": "logback-xml-transformer",
    "option2": "logstash-logback-encoder",
    "option3": "jackson-logger",
    "option4": "slf4j-parser",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring Cache에서 캐시를 비우는 데 사용하는 어노테이션은?",
    "option1": "@CacheClear",
    "option2": "@CacheEvict",
    "option3": "@CacheDrop",
    "option4": "@CacheReset",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "Spring Batch의 Reader, Processor, Writer 구조를 사용하는 이유는?",
    "option1": "코드를 짧게 줄이기 위해",
    "option2": "병렬 처리를 방지하기 위해",
    "option3": "대량 데이터를 효율적으로 처리하기 위해",
    "option4": "네트워크 연결을 단절하기 위해",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "로깅, 캐시, 배치 처리 도구",
    "chapterNum": 4
  },
  {
    "question": "JUnit5에서 테스트 메서드 위에 붙이는 기본 어노테이션은?",
    "option1": "@Execute",
    "option2": "@Start",
    "option3": "@Test",
    "option4": "@Run",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Mockito의 주요 사용 목적은?",
    "option1": "빌드 스크립트를 실행",
    "option2": "객체를 모킹하여 독립적인 테스트 수행",
    "option3": "실제 DB 연결 테스트",
    "option4": "배치 잡 실행을 예약",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Spring Boot에서 테스트 클래스에 붙이는 어노테이션은?",
    "option1": "@SpringTest",
    "option2": "@MockTest",
    "option3": "@BootTest",
    "option4": "@SpringBootTest",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Testcontainers의 가장 큰 장점은?",
    "option1": "실제 DB 환경과 동일한 조건으로 테스트 가능",
    "option2": "단위 테스트 속도 감소",
    "option3": "로컬 환경에서만 동작",
    "option4": "JVM에서만 실행",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Mockito에서 특정 메서드 호출을 검증하려면 사용하는 함수는?",
    "option1": "when()",
    "option2": "verify()",
    "option3": "assertThat()",
    "option4": "doReturn()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Gradle의 설정 파일 확장자는?",
    "option1": ".gradle",
    "option2": ".yaml",
    "option3": ".bat",
    "option4": ".conf",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Maven에서 의존성을 관리하는 기본 파일은?",
    "option1": "pom.gradle",
    "option2": "settings.gradle",
    "option3": "pom.xml",
    "option4": "maven.config",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "JUnit 테스트에서 예외 발생을 테스트할 때 사용하는 어노테이션은?",
    "option1": "@Test(expected = ...)",
    "option2": "@Throws",
    "option3": "@AssertException",
    "option4": "@Catch",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "Testcontainers는 어떤 기술을 기반으로 작동하는가?",
    "option1": "VMWare",
    "option2": "Gradle Wrapper",
    "option3": "Docker 컨테이너",
    "option4": "Spring Devtools",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  },
  {
    "question": "빌드 도구 중 멀티 모듈 프로젝트에서 자주 사용되는 도구는?",
    "option1": "Logback",
    "option2": "JUnit",
    "option3": "Gradle 또는 Maven",
    "option4": "Mockito",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트, 빌드, 개발 유틸 통합",
    "chapterNum": 5
  }




]
