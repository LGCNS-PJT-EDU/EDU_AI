[
  {
    "question": "Vue 템플릿에서 데이터 바인딩을 위한 기본 구문은?",
    "option1": "{{  }}",
    "option2": "[[  ]]",
    "option3": "{{{  }}}",
    "option4": "(())",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "Vue 인스턴스를 생성할 때 가장 먼저 호출되는 라이프사이클 훅은?",
    "option1": "beforeCreate",
    "option2": "created",
    "option3": "mounted",
    "option4": "beforeMount",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "템플릿에서 HTML 특수문자를 이스케이프하지 않고 그대로 출력하려면 사용하는 구문은?",
    "option1": "v-html=\"rawHtml\"",
    "option2": "{{ rawHtml }}",
    "option3": "v-bind:html=\"rawHtml\"",
    "option4": "v-text=\"rawHtml\"",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 Vue 템플릿에 JavaScript 표현식을 사용할 수 없는 위치는?",
    "option1": "v-bind 디렉티브 값",
    "option2": "v-on 디렉티브 핸들러",
    "option3": "속성 이름(attribute key)",
    "option4": "텍스트 보간(interpolation) 안",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "v-bind:class에 객체를 전달할 때, 클래스가 적용되는 조건은?",
    "option1": "키에 대응하는 값이 true일 때",
    "option2": "키가 문자열이 아닐 때",
    "option3": "값이 null일 때",
    "option4": "객체 길이가 0일 때",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "data 옵션에서 함수가 아닌 객체를 반환하면 발생하는 문제는?",
    "option1": "모든 인스턴스가 동일 객체를 공유해 반응성 오류",
    "option2": "템플릿 파싱이 실패하여 빌드 중단",
    "option3": "watcher가 자동으로 해제됨",
    "option4": "props 전달이 차단됨",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "‘this.message’가 DOM에 반영되는 시점은? (mounted 훅 내부에서 변경)",
    "option1": "mounted 훅 직후에 반영된다",
    "option2": "nextTick 이후 첫 렌더링 때 반영된다",
    "option3": "updated 훅 이후에만 반영된다",
    "option4": "DOM에는 절대 반영되지 않는다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "템플릿에서 v-bind 축약형으로 올바른 것은?",
    "option1": ":title=\"msg\"",
    "option2": ".bind(title)=\"msg\"",
    "option3": "@bind:title=\"msg\"",
    "option4": "#title=\"msg\"",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "v-on:click=\"count++\" 구문이 예상대로 동작하려면 count는 어디에 있어야 하는가?",
    "option1": "data()가 반환하는 객체",
    "option2": "methods 안",
    "option3": "computed 안",
    "option4": "watch 안",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 인스턴스 옵션 중 필수가 아닌 것은?",
    "option1": "methods",
    "option2": "data",
    "option3": "el / mount 대상",
    "option4": "template 또는 render",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "템플릿 구문 & 인스턴스 기초",
    "chapterNum": 1
  },
  {
    "question": "Vue 반응형 시스템의 핵심 개념은?",
    "option1": "데이터 변경 ↔ DOM 자동 동기화",
    "option2": "가상 DOM을 직접 조작",
    "option3": "양방향 바인딩 없는 단방향 흐름",
    "option4": "DOM 변화를 수동으로 감지",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "계산된 속성(computed)의 특징은?",
    "option1": "의존 데이터가 변할 때만 재평가",
    "option2": "무조건 매 렌더링마다 실행",
    "option3": "DOM 이벤트 발생 시에만 실행",
    "option4": "블로킹 I/O를 자동 회피",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "Vue 3에서 ref(0)으로 반환되는 값의 내부 형식은?",
    "option1": "객체 { value: 0 } (Proxied)",
    "option2": "Proxy 함수",
    "option3": "숫자 0 그 자체",
    "option4": "WeakMap",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watch와 computed의 주요 차이점으로 올바른 것은?",
    "option1": "watch는 부수 효과(side-effect) 실행용",
    "option2": "watch는 캐싱된 결과를 반환",
    "option3": "computed는 비동기 호출만 지원",
    "option4": "computed는 의존성 추적을 하지 않음",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "reactive()에 전달해도 반응형이 되지 않는 값은?",
    "option1": "Map 또는 Set",
    "option2": "평범한 Object",
    "option3": "배열(Array)",
    "option4": "중첩 객체가 없는 null-free 리터럴",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "DOM 갱신 후 실행하려면 다음 코드 뒤에 무엇을 해야 하는가? count.value++;",
    "option1": "await nextTick() 뒤에 console.log 실행",
    "option2": "flushSync()로 감싼다",
    "option3": "watchEffect 안에서 실행",
    "option4": "count.value += 0 으로 강제 트리거",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "Vue 3 반응형 시스템이 Vue 2의 defineProperty 대신 사용하는 기술은?",
    "option1": "ES6 Proxy",
    "option2": "MutationObserver",
    "option3": "WeakRef",
    "option4": "Reflect.metadata",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "shallowReactive()를 사용할 때의 이점은?",
    "option1": "루트 레벨만 반응형으로 만들어 메모리·성능 절약",
    "option2": "깊은 중첩 객체까지 자동 추적",
    "option3": "ref와 동일한 API 제공",
    "option4": "Computed 속성을 자동 생성",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watch 구성에서 deep:true, immediate:true가 비효율적인 경우는?",
    "option1": "변경 폭이 큰 대용량 중첩 객체를 감시",
    "option2": "원시형(ref) 값을 감시",
    "option3": "deep 옵션 false",
    "option4": "immediate false",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "watchEffect가 watch보다 적합한 상황은?",
    "option1": "의존 대상을 명시하기 힘든 복합 반응형 로직",
    "option2": "특정 하나의 ref 변경에만 반응",
    "option3": "비동기 API 호출 후 에러 처리",
    "option4": "props 유효성 검증",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "반응형 시스템",
    "chapterNum": 2
  },
  {
    "question": "요소를 조건부로 렌더링하기 위한 기본 디렉티브는?",
    "option1": "v-if",
    "option2": "v-for",
    "option3": "v-bind",
    "option4": "v-html",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "리스트 렌더링에 사용하는 디렉티브는?",
    "option1": "v-for",
    "option2": "v-show",
    "option3": "v-model",
    "option4": "v-once",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "양방향 폼 바인딩을 제공하는 디렉티브는?",
    "option1": "v-model",
    "option2": "v-text",
    "option3": "v-pre",
    "option4": "v-slot",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-show 디렉티브의 특징으로 올바른 것은?",
    "option1": "DOM을 한 번만 렌더링하고 display 속성을 토글",
    "option2": "조건이 false면 노드를 아예 생성하지 않는다",
    "option3": "렌더 비용이 v-if보다 높다",
    "option4": "서버 사이드 렌더링에서만 사용된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-bind .camel 수식어 기능은?",
    "option1": "kebab-case 속성명을 camelCase로 변환",
    "option2": "문자열 값을 자동으로 number로 변환",
    "option3": "HTML을 이스케이프하지 않고 출력",
    "option4": "true 값을 전달하면 속성을 제거",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "mounted 훅은 언제 호출되는가?",
    "option1": "DOM 삽입 직후 최초 한 번",
    "option2": "updated 훅 직후",
    "option3": "컴포넌트 생성 직후",
    "option4": "beforeUnmount 직전",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트 제거 직전에 호출되는 훅은?",
    "option1": "beforeUnmount",
    "option2": "unmounted",
    "option3": "beforeUpdate",
    "option4": "errorCaptured",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "Composition API에서 DOM 삽입 후 실행 훅 등록 함수는?",
    "option1": "onMounted",
    "option2": "onBeforeMount",
    "option3": "useMounted",
    "option4": "setupMounted",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "v-on .capture 수식어 역할은?",
    "option1": "이벤트를 캡처 단계에서 처리",
    "option2": "이벤트 버블링 중단",
    "option3": "수신 이벤트를 상위로 전파",
    "option4": "리스너를 한 번만 실행",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "@keyup.enter 수식어 의미는?",
    "option1": "Enter 키가 눌렸을 때만 keyup 핸들러 실행",
    "option2": "keyup 이벤트 캡처 단계",
    "option3": "Enter 키 아닌 경우 전파 중단",
    "option4": "keydown 이벤트 변환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "디렉티브 & 라이프사이클 훅",
    "chapterNum": 3
  },
  {
    "question": "부모 → 자식 데이터 전달 메커니즘은?",
    "option1": "props",
    "option2": "slots",
    "option3": "provide/inject",
    "option4": "$refs",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "자식이 부모에게 값을 전달할 때 호출하는 메서드는?",
    "option1": "$emit",
    "option2": "$dispatch",
    "option3": "$broadcast",
    "option4": "$send",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "기본(이름 없는) 슬롯 태그는?",
    "option1": "<slot>",
    "option2": "<slot name=\"default\">",
    "option3": "<template #default>",
    "option4": "<slot-default>",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "props 타입 유효성 검사 키는?",
    "option1": "type",
    "option2": "validator",
    "option3": "required",
    "option4": "default",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "전역 컴포넌트 등록 API는?",
    "option1": "app.component()",
    "option2": "Vue.use()",
    "option3": "defineComponent()",
    "option4": "createRenderer()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "스코프드 슬롯 템플릿 축약은?",
    "option1": "<template #item=\"slotProps\">",
    "option2": "<slot name=\"item\" :slotProps>",
    "option3": "<slot v-bind=\"item\">",
    "option4": "<template v-slot:itemProps>",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "prop 값을 직접 변경 시 결과는?",
    "option1": "Vue가 경고 출력, 변경은 반응형 아님",
    "option2": "부모 원본 데이터 즉시 변경",
    "option3": "변경 허용되나 반응성 깨짐",
    "option4": "런타임 에러 발생",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "Composition API 자식이 v-model 지원하려면 emit 이벤트는?",
    "option1": "update:modelValue",
    "option2": "modelValue",
    "option3": "input",
    "option4": "change:model",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "provide/inject 값을 반응형 유지하려면?",
    "option1": "reactive() 또는 ref()로 래핑한 값 제공",
    "option2": "원시 값 제공",
    "option3": "JSON 직렬화",
    "option4": "watchEffect 반환",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "슬롯 설명 중 틀린 것은?",
    "option1": "슬롯 콘텐츠는 부모 범위에서 컴파일",
    "option2": "동일 컴포넌트 슬롯 이름은 유일",
    "option3": "fallback 콘텐츠는 슬롯 비어 있을 때 표시",
    "option4": "스코프드 슬롯에서 자식→부모 데이터",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "컴포넌트·Props·슬롯",
    "chapterNum": 4
  },
  {
    "question": "Angular CLI에서 프로덕션용 번들을 생성하려면 어떤 명령을 사용해야 하는가?",
    "option1": "ng build --configuration production",
    "option2": "ng serve --prod",
    "option3": "ng deploy --prod",
    "option4": "ng compile --prod",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Angular의 Ahead-of-Time 컴파일(AOT) 주된 장점은?",
    "option1": "런타임에 컴파일 오버헤드가 제거되어 초기 로드 속도가 빨라진다",
    "option2": "템플릿 문법 오류를 무시하고 빌드를 계속한다",
    "option3": "의존성 주입을 비활성화해 번들 크기를 줄인다",
    "option4": "개발 서버가 자동 재시작된다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Angular 16의 기본 렌더러(컴파일러)로 채택된 엔진은?",
    "option1": "Ivy",
    "option2": "View Engine",
    "option3": "Renderer2",
    "option4": "Zone.js",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Jasmine 단위 테스트에서 비동기 호출 완료를 알리기 위해 주입하는 헬퍼는?",
    "option1": "done() 콜백",
    "option2": "fixture.detectChanges()",
    "option3": "fakeAsync()",
    "option4": "flushMicrotasks()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Angular PWA 변환을 자동으로 설정해 주는 CLI 스키매틱 명령은?",
    "option1": "ng add @angular/pwa",
    "option2": "ng generate pwa",
    "option3": "ng init --pwa",
    "option4": "ng add service-worker",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "앱을 국제화(i18n) 빌드할 때 locale 별 번들을 만들도록 지정하는 CLI 플래그는?",
    "option1": "--localize",
    "option2": "--i18n",
    "option3": "--translate",
    "option4": "--locale-build",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "앱 전반에 걸쳐 사용되지 않는 코드가 번들에 포함되지 않도록 하는 Webpack/CLI 최적화 기법은?",
    "option1": "Tree shaking",
    "option2": "Code splitting",
    "option3": "Inlining",
    "option4": "Polyfilling",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Angular Universal을 사용해 서버 사이드 렌더링(SSR)을 도입하면 얻는 직접적 이점으로 옳은 것은?",
    "option1": "초기 HTML이 완성되어 SEO와 첫 콘텐츠 페인트(FCP)가 개선된다",
    "option2": "브라우저 번들 크기가 자동으로 50% 감소한다",
    "option3": "Ivy가 비활성화되어 빌드 속도가 빨라진다",
    "option4": "RxJS 의존성이 제거된다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "ng test 명령이 기본적으로 사용하는 테스트 러너는?",
    "option1": "Karma",
    "option2": "Jest",
    "option3": "Mocha",
    "option4": "Vitest",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  },
  {
    "question": "Angular CLI 빌드 시 하위 브라우저용 ES5 코드 번들을 자동 생성해 주는 기능은?",
    "option1": "Differential loading",
    "option2": "Lazy chunk preloading",
    "option3": "Webpack module federation",
    "option4": "Inline critical CSS",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "라우팅·상태 관리 & Composition API",
    "chapterNum": 5
  }
]