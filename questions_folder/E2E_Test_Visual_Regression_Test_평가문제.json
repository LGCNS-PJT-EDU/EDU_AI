[
  {
    "question": "E2E(End-to-End) 테스트의 주요 목적은?",
    "option1": "단일 함수의 성능을 테스트하기 위해",
    "option2": "컴포넌트 단위 렌더링을 검증하기 위해",
    "option3": "전체 사용자 흐름이 정상적으로 작동하는지 확인하기 위해",
    "option4": "테스트 커버리지를 높이기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 E2E 테스트에 해당하는 시나리오는?",
    "option1": "계산 함수의 반환값 검증",
    "option2": "로그인 → 장바구니 담기 → 결제 완료까지 시뮬레이션",
    "option3": "컴포넌트 내부 상태 확인",
    "option4": "CSS class 적용 여부 확인",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트는 일반적으로 어떤 방식으로 실행되는가?",
    "option1": "서버 로그를 통해 결과를 분석",
    "option2": "테스트 전용 API를 통해 직접 테스트",
    "option3": "브라우저를 실제로 열어 사용자처럼 동작을 시뮬레이션",
    "option4": "백엔드만 대상으로 테스트",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트 도구로 널리 사용되는 것이 아닌 것은?",
    "option1": "Cypress",
    "option2": "Playwright",
    "option3": "Postman",
    "option4": "Selenium",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트 시 시나리오 설계에서 가장 먼저 고려할 점은?",
    "option1": "컴포넌트의 크기",
    "option2": "사용자의 실제 행동 흐름",
    "option3": "데이터베이스 용량",
    "option4": "브라우저 렌더링 성능",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "다음 중 E2E 테스트의 특징으로 올바른 설명은?",
    "option1": "코드 레벨의 정확한 단위 테스트가 된다",
    "option2": "빠르지만 신뢰도가 낮다",
    "option3": "느리지만 실제 사용자 경험을 반영할 수 있다",
    "option4": "브라우저 없이 실행된다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트가 단위 테스트에 비해 가지는 단점은?",
    "option1": "로컬에서 실행이 불가능하다",
    "option2": "실제 동작을 확인할 수 없다",
    "option3": "속도가 느리고, 설정이 복잡할 수 있다",
    "option4": "코드 커버리지를 높일 수 없다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트에서 테스트 환경을 격리해야 하는 주된 이유는?",
    "option1": "테스트 속도를 높이기 위해",
    "option2": "UI를 더 멋지게 보이게 하기 위해",
    "option3": "테스트 결과가 외부 상태에 따라 달라지지 않도록 하기 위해",
    "option4": "브라우저 화면을 크게 보기 위해",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트와 통합 테스트의 주된 차이점은?",
    "option1": "통합 테스트는 화면을 테스트하지 않는다",
    "option2": "E2E는 단일 함수 테스트이고, 통합은 전체 흐름 테스트다",
    "option3": "E2E는 실제 사용자 인터페이스를 테스트하고, 통합 테스트는 코드 간 상호작용을 테스트한다",
    "option4": "둘은 동일하다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "E2E 테스트에서 테스트가 실패했을 때 가장 먼저 해야 할 행동은?",
    "option1": "모든 테스트를 다시 작성한다",
    "option2": "실제 UI를 직접 열어 실패한 시나리오를 재현해본다",
    "option3": "코드를 전부 삭제한다",
    "option4": "다른 브라우저를 설치한다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "E2E 테스트 개요 & 자동화 흐름 이해",
    "chapterNum": 1
  },
  {
    "question": "Cypress에서 웹 페이지를 열기 위해 사용하는 명령어는?",
    "option1": "cy.open()",
    "option2": "cy.visit()",
    "option3": "cy.launch()",
    "option4": "cy.page()",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress에서 특정 요소를 선택하기 위한 명령어는?",
    "option1": "cy.select()",
    "option2": "cy.find()",
    "option3": "cy.get()",
    "option4": "cy.query()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress에서 텍스트 입력을 시뮬레이션하려면 어떤 명령어를 사용해야 하는가?",
    "option1": "cy.type()",
    "option2": "cy.input()",
    "option3": "cy.write()",
    "option4": "cy.fill()",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "버튼 클릭을 Cypress로 테스트하려면 어떤 명령어를 사용해야 하는가?",
    "option1": "cy.push()",
    "option2": "cy.click()",
    "option3": "cy.tap()",
    "option4": "cy.fire()",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress에서 체이닝 방식으로 연속 동작을 정의할 수 있는 이유는?",
    "option1": "모든 명령어가 비동기적으로 처리되기 때문",
    "option2": "JavaScript의 특성 때문",
    "option3": "Cypress는 HTML을 직접 수정하기 때문",
    "option4": "실제 브라우저를 사용하지 않기 때문",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Cypress에서 사용 가능한 Assertion 함수는?",
    "option1": "should()",
    "option2": "must()",
    "option3": "verify()",
    "option4": "assert()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress 테스트에서 ‘id가 login인 요소’를 선택하는 올바른 구문은?",
    "option1": "cy.get('login')",
    "option2": "cy.get('#login')",
    "option3": "cy.get('.login')",
    "option4": "cy.get('id=login')",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress에서 네트워크 요청을 가로채거나 대체할 때 사용하는 명령어는?",
    "option1": "cy.replace()",
    "option2": "cy.api()",
    "option3": "cy.intercept()",
    "option4": "cy.mock()",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "Cypress에서 테스트를 시작할 때 가장 먼저 정의하는 함수는?",
    "option1": "describe()",
    "option2": "start()",
    "option3": "suite()",
    "option4": "run()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "다음 중 Cypress의 ‘it()’ 함수의 목적은?",
    "option1": "테스트 스위트 전체 정의",
    "option2": "단일 테스트 시나리오를 정의",
    "option3": "환경 설정 수행",
    "option4": "스냅샷을 저장",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Cypress 실습 – 기본 명령어 & 흐름 구성",
    "chapterNum": 2
  },
  {
    "question": "E2E 테스트에서 로그인 후 페이지 접근 여부를 테스트하려면 어떤 흐름이 필요한가?",
    "option1": "컴포넌트 렌더링만 확인",
    "option2": "로그인 없이 바로 이동",
    "option3": "로그인 수행 후 토큰 기반 접근 확인",
    "option4": "스크린샷 저장 후 비교",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "Cypress에서 로그인 상태를 재사용하려면 가장 적절한 방법은?",
    "option1": "테스트마다 로그인 절차 반복",
    "option2": "브라우저 자동 리프레시 사용",
    "option3": "localStorage나 쿠키를 직접 설정",
    "option4": "테스트 후 세션을 삭제",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "Cypress에서 특정 URL로 이동했는지 검증할 때 사용하는 메서드는?",
    "option1": "cy.url()",
    "option2": "cy.path()",
    "option3": "cy.redirect()",
    "option4": "cy.location()",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "E2E 테스트에서 로그인과 같은 공통 작업을 테스트 전에 실행하려면 어떤 Hook을 사용하는가?",
    "option1": "before()",
    "option2": "setup()",
    "option3": "onLogin()",
    "option4": "preRun()",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "다음 중 상태가 여러 테스트 간 공유되지 않도록 하기 위한 전략은?",
    "option1": "브라우저 새로고침",
    "option2": "DOM 요소 초기화",
    "option3": "각 테스트마다 상태를 명시적으로 초기화",
    "option4": "URL을 변경하지 않음",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "라우팅 테스트에서 로그인하지 않은 사용자가 접근할 수 없도록 하는 테스트는?",
    "option1": "인증 우회 테스트",
    "option2": "보안 무시 테스트",
    "option3": "비인가 접근 차단 테스트",
    "option4": "라우팅 백도어 테스트",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "상태 검증에서 가장 중요하게 테스트해야 할 것은?",
    "option1": "상태 저장 위치",
    "option2": "Redux나 Zustand의 reducer 함수 호출 여부",
    "option3": "사용자의 인터랙션 결과로 UI가 올바르게 반영되었는지",
    "option4": "브라우저 쿠키 변경 여부",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "Cypress에서 로그인 API를 미리 호출하여 세션을 설정하는 방법은?",
    "option1": "cy.routeLogin()",
    "option2": "cy.session()",
    "option3": "cy.init()",
    "option4": "cy.apiAuth()",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "다음 중 상태 기반 UI 테스트에 포함될 수 없는 것은?",
    "option1": "버튼 클릭 후 텍스트가 변경되었는지 확인",
    "option2": "비동기 요청 후 목록이 갱신되었는지 확인",
    "option3": "컴포넌트 이름이 올바른지 확인",
    "option4": "상태에 따라 요소가 보이거나 숨겨졌는지 확인",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "E2E 테스트에서 사용자 상태에 따라 라우팅을 분기시키는 케이스를 테스트할 때 가장 중요한 점은?",
    "option1": "사용자 정보를 console.log로 출력하는 것",
    "option2": "로그인된 상태/비로그인 상태 모두를 분리해 시나리오를 테스트하는 것",
    "option3": "URL을 정적으로 지정하는 것",
    "option4": "브라우저를 수동 조작하는 것",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "고급 E2E 전략 – 인증, 라우팅, 상태 검증",
    "chapterNum": 3
  },
  {
    "question": "Visual Regression Test의 주요 목적은?",
    "option1": "코드 내부 로직을 검증하기 위해",
    "option2": "컴포넌트의 상태 관리를 테스트하기 위해",
    "option3": "UI의 시각적 변화 여부를 감지하기 위해",
    "option4": "페이지 로딩 속도를 측정하기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Visual Regression Test 도구가 아닌 것은?",
    "option1": "Percy",
    "option2": "jest-image-snapshot",
    "option3": "Chromatic",
    "option4": "Vitest",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "화면의 스냅샷을 저장하고 픽셀 단위로 비교하는 방식을 사용하는 테스트는?",
    "option1": "단위 테스트",
    "option2": "통합 테스트",
    "option3": "E2E 테스트",
    "option4": "Visual Regression Test",
    "answerIndex": 4,
    "difficulty": "하",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "Visual Regression Test가 실패하는 주요 이유는?",
    "option1": "코드가 너무 길어서",
    "option2": "UI가 이전과 다르게 렌더링되었기 때문",
    "option3": "브라우저 종류가 달라서",
    "option4": "서버가 응답하지 않아서",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "Percy와 같은 도구에서 시각적 차이를 허용하는 기준 값은?",
    "option1": "margin",
    "option2": "threshold",
    "option3": "resolution",
    "option4": "offset",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "Visual Regression Test를 구성할 때 테스트가 불안정해지는 주요 원인은?",
    "option1": "API 속도 변화",
    "option2": "브라우저 창 크기 불일치",
    "option3": "컴포넌트 이름 중복",
    "option4": "로딩 스피너 미적용",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "다음 중 VRT를 적용하기 가장 적절한 대상은?",
    "option1": "네트워크 요청",
    "option2": "Redux 상태 변경",
    "option3": "버튼 위치, 폰트 크기 등의 UI 요소",
    "option4": "서버 응답 시간",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "Chromatic은 어떤 프레임워크 기반에서 동작하는 VRT 도구인가?",
    "option1": "Storybook",
    "option2": "React Testing Library",
    "option3": "Cypress",
    "option4": "Next.js",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "jest-image-snapshot의 역할은?",
    "option1": "이미지를 애니메이션으로 변환",
    "option2": "이미지를 저장하고 이전 이미지와 비교",
    "option3": "브라우저 렌더링을 가속",
    "option4": "컴포넌트 이름을 리팩터링",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "Visual Regression Test에서 false positive를 줄이기 위한 전략은?",
    "option1": "이미지 비교를 제거한다",
    "option2": "threshold를 0으로 설정한다",
    "option3": "애니메이션 요소를 제외하거나 지연시간(wait)을 설정한다",
    "option4": "매번 스냅샷을 덮어쓴다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Visual Regression Test 원리 & 도구",
    "chapterNum": 4
  },
  {
    "question": "E2E 테스트와 Visual Regression Test를 함께 사용하는 가장 큰 이유는?",
    "option1": "테스트 실행 속도를 높이기 위해",
    "option2": "코드 커버리지를 자동 계산하기 위해",
    "option3": "기능 흐름과 UI 변경을 동시에 검증하기 위해",
    "option4": "서버 상태를 유지하기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 E2E + VRT 통합 전략에 해당하지 않는 것은?",
    "option1": "로그인 후 페이지 이동과 화면 비교를 함께 수행",
    "option2": "버튼 클릭 후 발생하는 UI 변경을 시각적으로 캡처",
    "option3": "데이터베이스 백업만 테스트",
    "option4": "사용자 흐름 기반 테스트에 스냅샷 비교 추가",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "E2E + VRT를 통합할 때 가장 먼저 고려해야 할 것은?",
    "option1": "데이터베이스 마이그레이션",
    "option2": "브라우저 호환성 문제",
    "option3": "테스트 대상의 사용자 흐름과 시각적 변화 포인트 정의",
    "option4": "컴포넌트 폴더 구조",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 실제 사용자 시나리오 + UI 비교를 자동화하는 데 가장 적합한 조합은?",
    "option1": "Jest + Webpack",
    "option2": "Cypress + Percy",
    "option3": "React Testing Library + ESLint",
    "option4": "Vitest + Tailwind",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "E2E + VRT 테스트에서 동일한 테스트가 자주 실패한다면 먼저 확인해야 할 것은?",
    "option1": "화면 캡처 타이밍과 애니메이션 여부",
    "option2": "테스트 파일명",
    "option3": "CSS 변수 정의 방식",
    "option4": "사용자 ID 값",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 E2E → VRT 흐름을 구성한 예시로 올바른 것은?",
    "option1": "1. 스냅샷 찍기 → 2. 로그인 → 3. 클릭",
    "option2": "1. 클릭 → 2. 페이지 이동 → 3. 화면 캡처 → 4. 이미지 비교",
    "option3": "1. assert 호출 → 2. 테스트 종료 → 3. UI 스냅샷 저장",
    "option4": "1. 서버 로그 수집 → 2. 컴포넌트 리렌더링",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "E2E + VRT 통합 테스트 시, 테스트가 불안정하게 자주 깨질 경우 해결 전략은?",
    "option1": "스냅샷 비교를 제거한다",
    "option2": "테스트 실행 시간을 줄인다",
    "option3": "애니메이션 제거 및 특정 요소가 로드된 후 비교",
    "option4": "코드를 전체 리팩터링한다",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "다음 중 통합된 테스트 시나리오 예로 가장 적절한 것은?",
    "option1": "페이지 로딩 속도 측정만 수행",
    "option2": "사용자가 결제 버튼을 누르고 완료 화면의 디자인도 함께 검증",
    "option3": "Redux 상태만 비교",
    "option4": "컴포넌트 수동 클릭",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "E2E + VRT 통합 테스트에서 테스트 유지보수성을 높이기 위한 방법은?",
    "option1": "모든 스냅샷을 자동 업데이트",
    "option2": "기능별 테스트 시나리오 분리 및 UI 변화 최소화 기준 설정",
    "option3": "컴포넌트를 재설계한다",
    "option4": "테스트를 하나로 몰아넣는다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  },
  {
    "question": "CI 환경에서 E2E + VRT 통합 테스트를 자동화하려면 필요한 구성 요소는?",
    "option1": "npm run build 명령어만 있으면 됨",
    "option2": "GitHub Actions, 테스트 도구, 시각 비교 도구가 포함된 워크플로우",
    "option3": "브라우저 콘솔 로그",
    "option4": "크롬 확장 프로그램",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "E2E + VRT 통합 테스트 전략",
    "chapterNum": 5
  }
]