[
  {
    "question": "NgRx는 어떤 프레임워크를 기반으로 한 상태 관리 라이브러리인가?",
    "option1": "React",
    "option2": "Vue",
    "option3": "Angular",
    "option4": "Svelte",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx는 어떤 디자인 패턴에서 영감을 받았는가?",
    "option1": "MVC",
    "option2": "Flux",
    "option3": "MVVM",
    "option4": "Factory",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx에서 상태 관리를 위해 사용하는 핵심 단위는?",
    "option1": "Service",
    "option2": "Store",
    "option3": "Controller",
    "option4": "Directive",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx Store는 어떤 역할을 하는가?",
    "option1": "컴포넌트 생성",
    "option2": "상태 저장소 역할",
    "option3": "라우팅 제어",
    "option4": "HTTP 요청",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx의 구성 요소가 아닌 것은?",
    "option1": "Actions",
    "option2": "Reducers",
    "option3": "Pipes",
    "option4": "Selectors",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx에서 사용하는 상태는 어떤 성격을 가지는가?",
    "option1": "읽기 전용",
    "option2": "양방향 바인딩",
    "option3": "함수형 구조",
    "option4": "동적 할당",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx는 어떤 방식으로 상태 변화를 처리하는가?",
    "option1": "서비스 직접 호출",
    "option2": "컴포넌트 바인딩",
    "option3": "액션 → 리듀서",
    "option4": "setState 호출",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx는 Angular의 어떤 기능과 긴밀하게 통합되는가?",
    "option1": "서비스",
    "option2": "모듈 시스템",
    "option3": "RxJS",
    "option4": "라우터",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx Store의 주된 이점은?",
    "option1": "동적 스타일링",
    "option2": "상태 추적 가능",
    "option3": "라우팅 단순화",
    "option4": "컴포넌트 자동 생성",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx는 어떤 언어의 기능을 강하게 활용하는가?",
    "option1": "Java",
    "option2": "Kotlin",
    "option3": "JavaScript",
    "option4": "TypeScript",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "NgRx 기본 개념",
    "chapterNum": 1
  },
  {
    "question": "NgRx에서 상태를 변경하기 위해 사용하는 함수는?",
    "option1": "Reducer",
    "option2": "Selector",
    "option3": "Effect",
    "option4": "Service",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "Action 객체가 반드시 가져야 하는 속성은?",
    "option1": "payload",
    "option2": "state",
    "option3": "type",
    "option4": "reducer",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "createAction을 통해 생성된 액션은 어떤 함수인가?",
    "option1": "컴포넌트 생성 함수",
    "option2": "비동기 호출 함수",
    "option3": "액션 생성자 함수",
    "option4": "리듀서 함수",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "createReducer의 주된 목적은?",
    "option1": "state 초기화",
    "option2": "비동기 트리거",
    "option3": "state 업데이트 정의",
    "option4": "라우팅 처리",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "on() 함수는 어떤 경우에 사용되는가?",
    "option1": "컴포넌트 마운트 시",
    "option2": "액션 타입에 따라 상태 변경 정의 시",
    "option3": "비동기 호출 시",
    "option4": "라우터 트리거",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "상태를 변경하지 않고 유지하려면 리듀서 내에서 무엇을 반환해야 하는가?",
    "option1": "null",
    "option2": "undefined",
    "option3": "기존 상태 그대로",
    "option4": "empty object",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "Action은 일반적으로 어떤 형식으로 정의되는가?",
    "option1": "클래스",
    "option2": "JSON",
    "option3": "객체 리터럴",
    "option4": "함수",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "createReducer의 인자로 전달되는 값은?",
    "option1": "초기 상태와 on() 배열",
    "option2": "reducer 함수",
    "option3": "selector 목록",
    "option4": "effect 핸들러",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "Reducer 함수에서 상태를 변경할 때 지켜야 할 원칙은?",
    "option1": "직접 변경",
    "option2": "불변성을 유지하며 새 객체 반환",
    "option3": "기존 상태에 추가",
    "option4": "비동기 변경",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "Action이 Reducer에 도달하려면 무엇을 통해 전달되는가?",
    "option1": "dispatch",
    "option2": "store.select",
    "option3": "effect.send",
    "option4": "module.emit",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "State, Actions, Reducers",
    "chapterNum": 2
  },
  {
    "question": "NgRx에서 Effects의 주된 목적은?",
    "option1": "뷰 렌더링",
    "option2": "비동기 작업 처리",
    "option3": "라우터 제어",
    "option4": "스토어 생성",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "Effects는 어떤 라이브러리를 활용하여 작동하는가?",
    "option1": "rxjs",
    "option2": "lodash",
    "option3": "zone.js",
    "option4": "redux",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "createEffect 함수는 어떤 값을 반환하는가?",
    "option1": "함수",
    "option2": "Observable",
    "option3": "Promise",
    "option4": "Action",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "Effects 클래스에서 액션을 주입받는 기본 속성은?",
    "option1": "store",
    "option2": "actions$",
    "option3": "dispatch",
    "option4": "select",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "다음 중 switchMap을 사용하는 이유는?",
    "option1": "동기 처리",
    "option2": "이전 요청 취소 후 새 요청",
    "option3": "순차 실행",
    "option4": "에러 무시",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "NgRx Effects는 액션을 어디로 전달하는가?",
    "option1": "Selector",
    "option2": "Reducer",
    "option3": "Service",
    "option4": "Component",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "ofType() 오퍼레이터의 역할은?",
    "option1": "타입별로 액션 필터링",
    "option2": "에러 처리",
    "option3": "Observable 생성",
    "option4": "스토어 구독",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "Effects 내에서 비동기 작업 후 상태를 변경하려면 무엇을 호출해야 하는가?",
    "option1": "select()",
    "option2": "dispatch()",
    "option3": "new Action()",
    "option4": "다른 액션 반환",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "createEffect를 정의할 때 두 번째 인자의 옵션으로 사용되는 속성은?",
    "option1": "type",
    "option2": "payload",
    "option3": "dispatch",
    "option4": "async",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "NgRx Effects를 사용하지 않고도 비동기 처리가 가능한가?",
    "option1": "가능하지만 관리 어려움",
    "option2": "절대 불가능",
    "option3": "기본 제공됨",
    "option4": "Vue에서만 가능",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Effects와 비동기 처리",
    "chapterNum": 3
  },
  {
    "question": "NgRx에서 상태를 읽을 때 사용하는 함수는?",
    "option1": "dispatch()",
    "option2": "createEffect()",
    "option3": "select()",
    "option4": "provideStore()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Selector의 주요 목적은?",
    "option1": "상태 변경",
    "option2": "상태 추출 및 계산",
    "option3": "액션 생성",
    "option4": "라우팅 처리",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "createSelector 함수는 어디에 정의되는가?",
    "option1": "@ngrx/effects",
    "option2": "@ngrx/store",
    "option3": "@ngrx/router",
    "option4": "@angular/common",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Selector의 장점 중 아닌 것은?",
    "option1": "재사용 가능",
    "option2": "성능 최적화",
    "option3": "메모이제이션 지원",
    "option4": "자동 상태 변경",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Store에서 select()를 사용하려면 무엇이 필요한가?",
    "option1": "action type",
    "option2": "selector 함수",
    "option3": "reducer map",
    "option4": "router config",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "createFeatureSelector는 어떤 용도로 사용되는가?",
    "option1": "feature module 생성",
    "option2": "전체 상태 접근",
    "option3": "특정 슬라이스 접근",
    "option4": "디버깅용",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Selector가 상태를 감지할 수 있도록 도와주는 것은?",
    "option1": "Reducer",
    "option2": "Observable",
    "option3": "Promise",
    "option4": "Component",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Store에서 상태를 구독하려면 어떤 연산자를 사용하는가?",
    "option1": "pipe()",
    "option2": "map()",
    "option3": "catchError()",
    "option4": "filter()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Selector는 어떤 패턴을 기반으로 동작하는가?",
    "option1": "비동기 트리거",
    "option2": "구독/발행",
    "option3": "명령형 제어",
    "option4": "Event bubbling",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "Selector 내부에서 다른 Selector를 조합할 수 있는 기능은?",
    "option1": "createState()",
    "option2": "combine()",
    "option3": "createSelector()",
    "option4": "onSelect()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Selectors와 Store 접근",
    "chapterNum": 4
  },
  {
    "question": "NgRx Entity의 주요 목적은?",
    "option1": "비동기 요청 처리",
    "option2": "데이터 정규화 및 목록 관리",
    "option3": "라우터 상태 관리",
    "option4": "로딩 상태 추적",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "NgRx Entity는 어떤 형태의 데이터를 관리하기에 적합한가?",
    "option1": "단일 객체",
    "option2": "비동기 응답",
    "option3": "ID 기반 다수 객체",
    "option4": "로컬 변수",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "Entity Adapter를 생성하는 함수는?",
    "option1": "createReducer",
    "option2": "createEntityAdapter",
    "option3": "createSelector",
    "option4": "defineAdapter",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "Entity State에 포함되지 않는 기본 속성은?",
    "option1": "ids",
    "option2": "entities",
    "option3": "selectedEntity",
    "option4": "adapter",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "NgRx Entity에서 단일 항목을 가져오는 함수는?",
    "option1": "selectEntity",
    "option2": "getEntityById",
    "option3": "selectById",
    "option4": "findEntity",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "addOne(), updateOne(), removeOne()은 무엇의 메서드인가?",
    "option1": "NgRx Store",
    "option2": "Reducer",
    "option3": "Entity Adapter",
    "option4": "Selector",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "Entity Adapter에서 상태를 초기화할 때 사용하는 함수는?",
    "option1": "initializeState",
    "option2": "setState",
    "option3": "getInitialState",
    "option4": "init()",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "NgRx Entity는 주로 어떤 성격의 앱에 유용한가?",
    "option1": "단순 입력",
    "option2": "많은 목록 데이터를 다루는 앱",
    "option3": "정적 웹사이트",
    "option4": "싱글 컴포넌트 앱",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "Entity에서 다수의 항목을 추가하는 함수는?",
    "option1": "addMany",
    "option2": "insertMany",
    "option3": "pushList",
    "option4": "mergeEntities",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  },
  {
    "question": "Entity Adapter는 어떤 방식으로 상태를 변경하는가?",
    "option1": "state 직접 수정",
    "option2": "불변성 유지하며 새 상태 반환",
    "option3": "setter 호출",
    "option4": "데이터베이스 변경",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "NgRx Entity와 고급 기능",
    "chapterNum": 5
  }
]