[
  {
    "question": "JSX에서 하나의 컴포넌트가 반환할 수 있는 요소는?",
    "option1": "하나의 부모 요소만 반환해야 한다",
    "option2": "여러 개의 형제 요소를 반환할 수 있다",
    "option3": "모든 요소를 <script> 태그로 감싸야 한다",
    "option4": "JSX에서는 요소 반환이 필요 없다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 JSX 문법으로 올바른 것은?",
    "option1": "<div class='container'>",
    "option2": "<div className='container'>",
    "option3": "<div classname='container'>",
    "option4": "<div ClassName='container'>",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "React 컴포넌트 이름은 어떤 규칙을 따라야 하는가?",
    "option1": "소문자로 시작해야 한다",
    "option2": "중괄호로 감싸야 한다",
    "option3": "대문자로 시작해야 한다",
    "option4": "파일 이름과 동일해야 한다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "JSX에서 JavaScript 표현식을 사용할 때 어떤 기호를 사용하는가?",
    "option1": "[]",
    "option2": "{}",
    "option3": "()",
    "option4": "<>",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "JSX에서 주석을 다는 올바른 방법은?",
    "option1": "// 주석",
    "option2": "<!-- 주석 -->",
    "option3": "{/* 주석 */}",
    "option4": "# 주석",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "다음 중 JSX에서 유효한 self-closing 태그는?",
    "option1": "<br>",
    "option2": "<img>",
    "option3": "<input/>",
    "option4": "<div></div>",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "컴포넌트의 기본 구조로 올바른 것은?",
    "option1": "function App() { return <h1>Hello</h1>; }",
    "option2": "let App = () => (<h1>Hello</h1>)",
    "option3": "component App() => <h1>Hello</h1>",
    "option4": "function App: return (<h1>Hello</h1>)",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "JSX 내에서 조건부 렌더링을 위해 주로 사용하는 연산자는?",
    "option1": "??",
    "option2": "==",
    "option3": "&&",
    "option4": "!=",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "컴포넌트를 export 하는 기본 방법은?",
    "option1": "module.export = ComponentName;",
    "option2": "export default ComponentName;",
    "option3": "require(ComponentName);",
    "option4": "ComponentName.export();",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "JSX에서 style 속성을 사용할 때 올바른 형식은?",
    "option1": "style='color: red;'",
    "option2": "style={{color: 'red'}}",
    "option3": "style='{{color: red}}'",
    "option4": "style=(color: red)",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "JSX 및 컴포넌트 기초",
    "chapterNum": 1
  },
  {
    "question": "React에서 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용하는 것은?",
    "option1": "props",
    "option2": "state",
    "option3": "context",
    "option4": "ref",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "다음 중 props의 특징으로 올바른 것은?",
    "option1": "변경 가능한 값이다",
    "option2": "부모 → 자식 방향의 데이터 전달이다",
    "option3": "컴포넌트 내부에서만 사용된다",
    "option4": "setProps로 값을 변경한다",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "컴포넌트 내부에서 값의 변경에 따라 다시 렌더링되도록 하는 데이터는?",
    "option1": "props",
    "option2": "state",
    "option3": "context",
    "option4": "variable",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "React에서 state를 변경할 수 있는 올바른 방법은?",
    "option1": "state = newValue",
    "option2": "this.state.update(newValue)",
    "option3": "setState(newValue)",
    "option4": "state.set(newValue)",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "함수형 컴포넌트에서 state를 사용하기 위해 import해야 할 Hook은?",
    "option1": "useEffect",
    "option2": "useState",
    "option3": "useReducer",
    "option4": "useMemo",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "다음 중 useState의 기본 사용법으로 옳은 것은?",
    "option1": "const state = useState(0)",
    "option2": "let [state] = useState(0)",
    "option3": "const [count, setCount] = useState(0)",
    "option4": "state, setState = useState(0)",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "props를 통해 전달된 값을 변경하려고 할 때의 올바른 대응은?",
    "option1": "setState로 복사본을 변경한다",
    "option2": "props 값을 직접 변경한다",
    "option3": "ref를 사용해 수정한다",
    "option4": "forceUpdate로 무시하고 렌더링한다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "state는 다음 중 어느 시점에 React가 컴포넌트를 다시 렌더링하도록 만드는가?",
    "option1": "state 변경 시",
    "option2": "props 선언 시",
    "option3": "컴포넌트 mount 시",
    "option4": "CSS 클래스가 바뀔 때",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "다음 중 props와 state의 공통점은?",
    "option1": "컴포넌트 간 공유 가능",
    "option2": "변경 시 UI 자동 업데이트",
    "option3": "함수형 컴포넌트에서만 사용",
    "option4": "직접 수정 가능",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "props의 타입을 미리 지정하여 유효성 검사를 하고 싶을 때 사용하는 것은?",
    "option1": "TypeGuard",
    "option2": "PropTypes",
    "option3": "TypeScript",
    "option4": "validateProps",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Props와 State",
    "chapterNum": 2
  },
  {
    "question": "React에서 클릭 이벤트를 등록할 때 사용하는 속성은?",
    "option1": "onClick",
    "option2": "onclick",
    "option3": "click",
    "option4": "addEventListener",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "SyntheticEvent의 기본 동작을 취소하려면 이벤트 객체에서 어떤 메서드를 호출해야 하는가?",
    "option1": "preventDefault()",
    "option2": "stopPropagation()",
    "option3": "cancelBubble()",
    "option4": "halt()",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "다음 중 && 연산자를 이용한 조건부 렌더링으로 올바른 것은?",
    "option1": "{isLoggedIn && <Dashboard />}",
    "option2": "{isLoggedIn ? <Dashboard />}",
    "option3": "{isLoggedIn || <Dashboard />}",
    "option4": "isLoggedIn && <Dashboard />",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "이벤트 핸들러에 인자를 전달하기 위한 가장 일반적인 방법은?",
    "option1": "onClick={() => handleClick(id)}",
    "option2": "onClick={handleClick(id)}",
    "option3": "onClick={handleClick.bind(this, id)()}",
    "option4": "onClick=\"handleClick(id)\"",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "삼항 연산자를 사용한 조건부 렌더링 예시로 적절한 것은?",
    "option1": "{isLoggedIn ? <Logout /> : <Login />}",
    "option2": "{isLoggedIn && <Login /> : <Logout />}",
    "option3": "{isLoggedIn ? <Login />}",
    "option4": "{<Login /> ? isLoggedIn : <Logout />}",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트가 특정 조건에서 아무것도 렌더링하지 않도록 하려면 일반적으로 무엇을 반환하는가?",
    "option1": "null",
    "option2": "undefined",
    "option3": "'' (빈 문자열)",
    "option4": "false",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "이벤트 버블링을 중단하려면 SyntheticEvent에서 어떤 메서드를 호출해야 하는가?",
    "option1": "stopPropagation()",
    "option2": "preventDefault()",
    "option3": "stopBubble()",
    "option4": "halt()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "다음 중 조건에 따라 클래스 이름을 동적으로 지정한 올바른 JSX 구문은?",
    "option1": "<div className={isActive ? 'active' : ''}></div>",
    "option2": "<div class='isActive && active'></div>",
    "option3": "<div className='isActive ? active'></div>",
    "option4": "<div className={isActive && 'active'}></div>",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "React에서 SyntheticEvent 객체는 이벤트 핸들러 종료 후 값을 재사용할 수 없는데, 이를 예외적으로 보존하려면 호출해야 하는 메서드는?",
    "option1": "persist()",
    "option2": "keep()",
    "option3": "save()",
    "option4": "cache()",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "다음 코드가 0을 렌더링하는 문제를 방지하기 위한 권장 방법은?\n{messages.length && <Badge count={messages.length} />}",
    "option1": "messages.length > 0 && <Badge count={messages.length} />",
    "option2": "messages.length || <Badge count={messages.length} />",
    "option3": "{messages.length !== 0 && <Badge count={messages.length} />}",
    "option4": "messages.length && Badge(count={messages.length})",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "이벤트 처리와 조건부 렌더링",
    "chapterNum": 3
  },
  {
    "question": "배열을 JSX로 변환할 때 가장 흔히 사용하는 배열 메서드는?",
    "option1": "map()",
    "option2": "forEach()",
    "option3": "filter()",
    "option4": "reduce()",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "key prop은 일반적으로 어디에 지정해야 하는가?",
    "option1": "map()이 반환하는 각 형제 요소의 최상위 태그",
    "option2": "ul·ol 같은 부모 컨테이너",
    "option3": "리스트 내부 모든 하위 요소",
    "option4": "key prop은 필수가 아니다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "React key에 대한 기본 규칙으로 올바른 것은?",
    "option1": "형제 사이에서 고유해야 한다",
    "option2": "페이지 전체에서 절대 고유해야 한다",
    "option3": "숫자만 사용할 수 있다",
    "option4": "렌더마다 새로운 값을 부여해야 한다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "다음 중 인덱스를 key로 사용해도 비교적 안전한 경우는?",
    "option1": "항목이 절대 추가·삭제·재정렬되지 않는 정적 목록",
    "option2": "사용자가 드래그로 순서를 바꾸는 목록",
    "option3": "동적으로 삽입·삭제되는 Todo 리스트",
    "option4": "컨트롤된 input 필드를 가진 양방향 폼",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "key를 생략하면 React가 주로 어떤 반응을 보이는가?",
    "option1": "개발자 콘솔에 경고를 출력한다",
    "option2": "컴파일 오류가 발생한다",
    "option3": "렌더링이 완전히 중단된다",
    "option4": "성능이 자동으로 최적화된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Fragment에 key를 부여하는 올바른 문법은?",
    "option1": "<React.Fragment key={item.id}>...</React.Fragment>",
    "option2": "<Fragment key>{...}</Fragment>",
    "option3": "<></> key={item.id}",
    "option4": "<Fragment id={item.id}>...</Fragment>",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "렌더마다 Math.random() 값을 key로 사용하면 주로 발생하는 문제는?",
    "option1": "모든 자식이 매번 언마운트·리마운트되어 상태가 초기화된다",
    "option2": "컴파일 타임 타입 오류가 발생한다",
    "option3": "브라우저 캐시가 비활성화된다",
    "option4": "React가 diff 과정을 건너뛴다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "리스트가 자주 재정렬될 때 가장 바람직한 key 선택은?",
    "option1": "데이터베이스에서 받은 고유 id",
    "option2": "배열 길이",
    "option3": "Date.now()로 만든 타임스탬프",
    "option4": "요소의 화면 좌표값",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "중첩(map 안의 map) 리스트를 렌더링할 때 key를 꼭 부여해야 하는 위치는?",
    "option1": "각 map이 반환하는 최상위 형제 요소",
    "option2": "가장 바깥 컨테이너 한 곳만",
    "option3": "가장 안쪽 요소 한 곳만",
    "option4": "key는 한 레벨에서만 허용된다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "다음 중 key prop에 대한 설명으로 옳지 않은 것은?",
    "option1": "문자열 또는 숫자처럼 직렬화 가능한 값이어야 한다",
    "option2": "컴포넌트가 재사용되는 동안 변하지 않아야 한다",
    "option3": "React diff 알고리즘이 요소 정체성을 추적할 때 사용한다",
    "option4": "렌더링 간 변경하면 DOM 최적화가 강화된다",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "리스트 렌더링과 키",
    "chapterNum": 4
  },
  {
    "question": "함수형 컴포넌트에서 전역 컨텍스트 값을 읽어올 때 사용하는 Hook은?",
    "option1": "useContext",
    "option2": "useState",
    "option3": "useReducer",
    "option4": "useMemo",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "사용자 정의 Hook을 만들 때 반드시 지켜야 하는 명명 규칙은?",
    "option1": "use로 시작해야 한다",
    "option2": "대문자로 시작해야 한다",
    "option3": "with로 시작해야 한다",
    "option4": "Hook 접미사를 붙여야 한다",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "useEffect의 두 번째 인수에 빈 배열([])을 전달하면 언제 실행되는가?",
    "option1": "컴포넌트가 처음 마운트될 때만",
    "option2": "모든 렌더링마다",
    "option3": "의존성 값이 변경될 때마다",
    "option4": "언마운트될 때만",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "useRef로 생성한 ref.current 값의 핵심 특징은?",
    "option1": "렌더 사이에 값이 바뀌어도 재렌더링을 일으키지 않는다",
    "option2": "값이 변경되면 자동으로 상태 업데이트가 발생한다",
    "option3": "DOM 엘리먼트에만 사용할 수 있다",
    "option4": "매 렌더링마다 새로운 객체가 생성된다",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "복잡한 상태 전이를 깔끔하게 관리하기 위해 useState 대신 권장되는 Hook은?",
    "option1": "useReducer",
    "option2": "useCallback",
    "option3": "useMemo",
    "option4": "useRef",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "계산 비용이 큰 값을 메모이제이션하여 렌더링 성능을 최적화할 때 사용하는 Hook은?",
    "option1": "useMemo",
    "option2": "useEffect",
    "option3": "useLayoutEffect",
    "option4": "useCallback",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "다음 코드에서 handleClick 함수가 매 렌더링마다 새로 생성되는 문제를 방지하려면?",
    "option1": "const handleClick = useCallback(() => setCount(c => c + 1), []);",
    "option2": "const handleClick = useMemo(() => () => setCount(c => c + 1), []);",
    "option3": "const handleClick = useEffect(() => setCount(c => c + 1), []);",
    "option4": "const handleClick = useRef(() => setCount(c => c + 1));",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "useEffect 콜백이 반환하는 함수의 주 용도는?",
    "option1": "이전 effect를 정리(clean-up)하는 데 사용된다",
    "option2": "의존성 배열을 강제로 재계산한다",
    "option3": "렌더링 결과를 직접 DOM에 삽입한다",
    "option4": "상태 업데이트를 배치(batching)한다",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "자식 컴포넌트의 DOM 혹은 인스턴스에 부모가 접근할 수 있도록 만드는 고급 기술은?",
    "option1": "forwardRef",
    "option2": "memo",
    "option3": "lazy",
    "option4": "StrictMode",
    "answerIndex": 1,
    "difficulty": "상",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  },
  {
    "question": "Hooks의 핵심 규칙으로 옳지 않은 것은?",
    "option1": "Hook은 함수형 컴포넌트 최상위에서만 호출해야 한다",
    "option2": "Hook은 조건문·반복문 안에서 자유롭게 호출할 수 있다",
    "option3": "커스텀 Hook 내부에서도 다른 Hook을 호출할 수 있다",
    "option4": "Class 컴포넌트에서는 Hook을 사용할 수 없다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Hooks 및 고급 컴포넌트 구성",
    "chapterNum": 5
  }
]