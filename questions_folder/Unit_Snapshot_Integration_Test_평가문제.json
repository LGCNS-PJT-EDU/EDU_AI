[
  {
    "question": "소프트웨어 테스트의 주요 목적 중 하나가 아닌 것은?",
    "option1": "버그를 사전에 방지하기 위해",
    "option2": "코드의 품질을 보장하기 위해",
    "option3": "프로젝트의 디자인을 결정하기 위해",
    "option4": "기능이 의도대로 동작하는지 확인하기 위해",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "단위 테스트(Unit Test)는 보통 어떤 범위를 테스트하는가?",
    "option1": "전체 페이지 흐름",
    "option2": "데이터베이스 연결",
    "option3": "개별 함수나 메서드",
    "option4": "네트워크 요청 전체",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "테스트 피라미드에서 가장 많은 수를 차지해야 하는 테스트는?",
    "option1": "단위 테스트",
    "option2": "스냅샷 테스트",
    "option3": "통합 테스트",
    "option4": "E2E 테스트",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "TDD(Test Driven Development)의 순서로 올바른 것은?",
    "option1": "코딩 → 테스트 → 리팩터링",
    "option2": "테스트 → 코딩 → 리팩터링",
    "option3": "디자인 → 코딩 → 테스트",
    "option4": "리팩터링 → 테스트 → 코딩",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "E2E(End-to-End) 테스트의 주요 목적은?",
    "option1": "모듈 간의 상호작용만 테스트",
    "option2": "단일 함수의 반환 값 테스트",
    "option3": "실제 사용자 흐름을 시뮬레이션하여 전반적인 기능 확인",
    "option4": "컴포넌트 내부 상태만 검증",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "통합 테스트(Integration Test)의 핵심 목적은?",
    "option1": "하나의 API 응답만 확인",
    "option2": "모든 데이터베이스 데이터를 삭제",
    "option3": "여러 모듈이 함께 작동하는지를 확인",
    "option4": "브라우저 렌더링 최적화",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "Mock 객체는 어떤 목적으로 사용되는가?",
    "option1": "실제 UI 렌더링 속도를 측정하기 위해",
    "option2": "실제 의존성을 제거하고 테스트 대상에 집중하기 위해",
    "option3": "컴파일 시간을 단축하기 위해",
    "option4": "스타일을 테스트하기 위해",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "Stub과 Spy의 차이점으로 올바른 설명은?",
    "option1": "Stub은 호출 여부를 기록하고 Spy는 반환 값을 고정한다",
    "option2": "Spy는 호출 여부를 기록하고 Stub은 미리 정의된 값을 반환한다",
    "option3": "둘은 완전히 동일하다",
    "option4": "Stub은 네트워크 요청에만 사용된다",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "다음 중 테스트 유지보수를 어렵게 만드는 주요 원인은?",
    "option1": "테스트가 너무 작아서 디버깅이 쉬움",
    "option2": "테스트가 명확하게 의도를 드러냄",
    "option3": "테스트가 구현 세부사항에 너무 의존함",
    "option4": "테스트가 모든 흐름을 자동화함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "테스트 작성 시점 중 '코드를 작성한 후 테스트하는 방식'을 부르는 말은?",
    "option1": "TDD",
    "option2": "BDD",
    "option3": "Test Last",
    "option4": "Test First",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "테스트 기본 개념 & 종류",
    "chapterNum": 1
  },
  {
    "question": "입력값을 받아 2배로 반환하는 순수 함수의 테스트에서 가장 중요한 검증 요소는?",
    "option1": "콘솔 출력 여부",
    "option2": "실행 시간",
    "option3": "입력에 따라 항상 예측 가능한 값을 반환하는지",
    "option4": "함수명이 의미론적으로 맞는지",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "Jest에서 테스트 함수를 작성할 때 사용하는 기본 함수는?",
    "option1": "run()",
    "option2": "test()",
    "option3": "verify()",
    "option4": "assert()",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "다음 중 단위 테스트가 아닌 것은?",
    "option1": "계산 함수가 올바르게 작동하는지 확인",
    "option2": "이벤트 핸들러가 특정 상태를 변경하는지 확인",
    "option3": "API 서버가 DB와 연결되는지 확인",
    "option4": "입력값 없이 반환값이 정해진 함수 검증",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "Jest에서 `expect(value).toBe(4)`에서 사용된 `toBe`는 어떤 역할을 하는가?",
    "option1": "값이 포함되어 있는지 확인",
    "option2": "객체의 구조를 비교",
    "option3": "값이 정확히 일치하는지 비교",
    "option4": "함수 호출 여부 확인",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "경계값 테스트(Boundary Test)가 중요한 이유는?",
    "option1": "UI에 더 가까운 테스트라서",
    "option2": "실행 시간이 길어서",
    "option3": "에러가 가장 자주 발생하는 구간이기 때문에",
    "option4": "개발자가 자주 빼먹는 요소이기 때문에",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "함수에 예외 상황을 강제로 발생시키고 그 처리를 검증하는 테스트는 어떤 유형인가?",
    "option1": "성능 테스트",
    "option2": "엣지 케이스 테스트",
    "option3": "예외 테스트",
    "option4": "경고 테스트",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "Jest에서 beforeEach() 함수의 주된 용도는?",
    "option1": "모든 테스트 후 리포트를 출력",
    "option2": "각 테스트가 실행되기 전에 초기화 작업 수행",
    "option3": "테스트 실행 여부 확인",
    "option4": "테스트 종료 후 정리",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "다음 중 순수 함수(Pure Function)의 특징이 아닌 것은?",
    "option1": "동일한 입력 → 동일한 출력",
    "option2": "외부 상태에 의존하지 않음",
    "option3": "부작용(side-effect)을 가짐",
    "option4": "예측 가능하고 테스트하기 쉬움",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "테스트 대상 함수가 내부적으로 다른 모듈을 호출할 경우 가장 적절한 단위 테스트 전략은?",
    "option1": "그대로 테스트",
    "option2": "그 모듈도 같이 실행",
    "option3": "Mocking을 통해 외부 모듈 의존 제거",
    "option4": "함수를 삭제함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "단위 테스트 작성 시 테스트 커버리지를 지나치게 100%로 맞추는 것이 비효율적인 이유는?",
    "option1": "코드를 짧게 유지할 수 없다",
    "option2": "의미 없는 테스트가 늘어날 수 있다",
    "option3": "코드가 느려진다",
    "option4": "테스트 파일이 너무 많아진다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Unit Test 실전 – 로직 & 함수 테스트",
    "chapterNum": 2
  },
  {
    "question": "React Testing Library에서 가장 기본이 되는 렌더링 함수는?",
    "option1": "renderComponent()",
    "option2": "mount()",
    "option3": "render()",
    "option4": "testRender()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트 내부의 버튼 클릭 이벤트 테스트에서 주로 사용하는 메서드는?",
    "option1": "fire()",
    "option2": "simulate()",
    "option3": "fireEvent.click()",
    "option4": "trigger()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트 테스트 시 `getByText()`는 어떤 요소를 찾는가?",
    "option1": "id 값이 같은 요소",
    "option2": "텍스트 노드에 해당하는 요소",
    "option3": "input name 속성의 값",
    "option4": "클래스명이 같은 요소",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "React 컴포넌트 테스트에서 `screen` 객체의 목적은?",
    "option1": "UI의 크기를 조정하기 위함",
    "option2": "테스트 화면을 캡처하기 위함",
    "option3": "DOM 탐색을 전역에서 수행할 수 있게 함",
    "option4": "스타일을 테스트하기 위함",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트에 `props`를 전달하여 렌더링 테스트를 할 때 사용하는 방법은?",
    "option1": "render(<Component>)",
    "option2": "render(Component, props)",
    "option3": "render(<Component {...props} />)",
    "option4": "mount(Component, props)",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "상태 변경(setState)이 발생하는 컴포넌트를 테스트할 때 필요한 함수는?",
    "option1": "waitFor()",
    "option2": "render()",
    "option3": "act()",
    "option4": "flush()",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "비동기 UI 요소가 나타나는 테스트에서 사용해야 할 방법은?",
    "option1": "getByText()",
    "option2": "queryByTestId()",
    "option3": "waitForElementToBeRemoved()",
    "option4": "waitFor()",
    "answerIndex": 4,
    "difficulty": "중",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "컴포넌트 테스트에서 사용자 입력을 시뮬레이션하려면 어떤 함수가 적절한가?",
    "option1": "simulateInput()",
    "option2": "fireEvent.change()",
    "option3": "act.input()",
    "option4": "input()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "테스트 대상 컴포넌트가 Context API를 사용하는 경우, 테스트 시 가장 적절한 방법은?",
    "option1": "useContext로 직접 호출",
    "option2": "Provider로 감싸서 렌더링",
    "option3": "mockProvider 사용 금지",
    "option4": "Context 내부를 무시",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "다음 중 '접근성 기준'에 따라 요소를 찾는 React Testing Library 함수는?",
    "option1": "getByText()",
    "option2": "getByRole()",
    "option3": "querySelector()",
    "option4": "getById()",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "React 컴포넌트 테스트",
    "chapterNum": 3
  },
  {
    "question": "Snapshot 테스트의 주요 목적은?",
    "option1": "컴포넌트의 UI가 변경되지 않았는지 검증하기 위해",
    "option2": "네트워크 지연을 테스트하기 위해",
    "option3": "브라우저 호환성을 확인하기 위해",
    "option4": "DB 연결을 확인하기 위해",
    "answerIndex": 1,
    "difficulty": "하",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "Jest에서 스냅샷 테스트를 생성하는 메서드는?",
    "option1": "toMatchText()",
    "option2": "toEqual()",
    "option3": "toMatchSnapshot()",
    "option4": "toRenderSame()",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "Snapshot 테스트가 실패했을 때 주로 해야 할 작업은?",
    "option1": "테스트를 무시한다",
    "option2": "브라우저를 재시작한다",
    "option3": "스냅샷을 업데이트하거나, 변경 원인을 확인한다",
    "option4": "파일명을 바꾼다",
    "answerIndex": 3,
    "difficulty": "하",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "다음 중 Mocking이 필요한 상황으로 적절한 것은?",
    "option1": "순수 함수 테스트 시",
    "option2": "DB와 연결된 의존 모듈을 테스트할 때",
    "option3": "DOM 구조가 없는 테스트",
    "option4": "static 파일 테스트",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "Jest의 `jest.fn()`은 어떤 역할을 하는가?",
    "option1": "새 DOM 요소를 생성한다",
    "option2": "비동기 API 요청을 실행한다",
    "option3": "Mock 함수(더미 함수)를 생성한다",
    "option4": "스냅샷을 자동 생성한다",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "Jest에서 특정 모듈을 Mock 처리하려면 사용하는 함수는?",
    "option1": "jest.module()",
    "option2": "jest.mock()",
    "option3": "mock.module()",
    "option4": "spyOn()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "Mock 함수가 실제로 호출되었는지를 확인하려면 어떤 Matcher를 사용해야 하는가?",
    "option1": "toBeCalled()",
    "option2": "toHaveBeenCalled()",
    "option3": "toMatchSnapshot()",
    "option4": "toEqual()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "스냅샷 테스트의 단점으로 적절한 것은?",
    "option1": "자동화가 되지 않는다",
    "option2": "UI가 너무 자주 바뀌면 테스트 유지가 어렵다",
    "option3": "로직을 테스트할 수 없다",
    "option4": "컴포넌트를 렌더링하지 않는다",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "비동기 API를 테스트할 때 실제 서버를 호출하지 않기 위해 사용하는 방식은?",
    "option1": "실제 API를 호출하고 검증",
    "option2": "코드를 주석 처리함",
    "option3": "Mock 서버나 Mock 데이터를 사용함",
    "option4": "그냥 무시하고 테스트함",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "다음 중 MSW(Mock Service Worker)의 주요 용도는?",
    "option1": "React 컴포넌트를 렌더링하기 위해",
    "option2": "HTML을 정리하기 위해",
    "option3": "실제 API를 대체하는 가짜 응답을 테스트에서 제공하기 위해",
    "option4": "데이터베이스 테스트를 위해",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Snapshot Test & Mock 전략",
    "chapterNum": 4
  },
  {
    "question": "통합 테스트(Integration Test)의 주요 목적은?",
    "option1": "단일 함수의 내부 동작 확인",
    "option2": "여러 모듈이 함께 작동하는 흐름을 검증",
    "option3": "브라우저 렌더링 속도 테스트",
    "option4": "사용자 입력 시뮬레이션 테스트",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "통합 테스트에서 주로 테스트하는 것은?",
    "option1": "데이터베이스 쿼리만 단독 테스트",
    "option2": "API 호출부터 화면 반영까지의 흐름",
    "option3": "서버 CPU 사용량",
    "option4": "HTML 정적 구조",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "React 기반의 통합 테스트에서 가장 흔히 테스트하는 시나리오는?",
    "option1": "컴포넌트 렌더링 여부만 확인",
    "option2": "버튼 클릭 시 API 요청 및 UI 변경 흐름",
    "option3": "DOM 트리 구조 출력",
    "option4": "단일 스타일 변경 테스트",
    "answerIndex": 2,
    "difficulty": "하",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "통합 테스트에서 상태 관리 라이브러리(Redux, Zustand 등)를 다룰 때 가장 중요한 것은?",
    "option1": "비동기 호출 순서만 보기",
    "option2": "store가 UI에 올바르게 반영되는지 확인",
    "option3": "reducer 내부 구현 확인",
    "option4": "액션 생성 함수 테스트",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "다음 중 React 앱에서 실제 사용자 흐름을 통합 테스트할 때 적절한 도구는?",
    "option1": "Cypress",
    "option2": "Prettier",
    "option3": "Webpack",
    "option4": "Babel",
    "answerIndex": 1,
    "difficulty": "중",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "비동기 통합 테스트에서 API 응답을 기다릴 때 사용하는 방식은?",
    "option1": "setTimeout",
    "option2": "async/await + waitFor() 조합",
    "option3": "done() 함수 제거",
    "option4": "forceFlush()",
    "answerIndex": 2,
    "difficulty": "중",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "API 요청 중 에러가 발생했을 때 UI가 제대로 에러 상태를 표시하는지 검증하는 테스트는?",
    "option1": "성능 테스트",
    "option2": "렌더링 테스트",
    "option3": "에러 처리 통합 테스트",
    "option4": "단위 테스트",
    "answerIndex": 3,
    "difficulty": "중",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "통합 테스트를 작성할 때 가장 중요한 고려사항은?",
    "option1": "컴포넌트 개수",
    "option2": "테스트가 실제 사용자 행동과 유사한지 여부",
    "option3": "코드 라인 수",
    "option4": "서버 상태",
    "answerIndex": 2,
    "difficulty": "상",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "다음 중 API 요청/응답을 Mock 처리해 통합 테스트하는 기술은?",
    "option1": "RTL Snapshot",
    "option2": "RESTClient",
    "option3": "Mock Service Worker (MSW)",
    "option4": "SASS Loader",
    "answerIndex": 3,
    "difficulty": "상",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  },
  {
    "question": "통합 테스트에서 ‘비정상 흐름’을 일부러 유도해 테스트하는 목적은?",
    "option1": "테스트 커버리지 확보를 위해",
    "option2": "코드를 더 빨리 실행하기 위해",
    "option3": "사용자에게 실제로 에러를 보여주기 위해",
    "option4": "의도된 예외 처리 경로가 안전하게 작동하는지 확인하기 위해",
    "answerIndex": 4,
    "difficulty": "상",
    "chapterName": "Integration Test & 실전 패턴",
    "chapterNum": 5
  }
]